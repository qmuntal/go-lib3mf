/*++

Copyright (C) 2019 3MF Consortium (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated Go wrapper file in order to allow an easy
use of the 3MF Library.

Interface version: 2.0.0

*/

// Code generated by Automatic Component Toolkit (ACT); DO NOT EDIT.

package lib3mf

/*
#include "lib3mf_abi.h"

void Lib3MFProgressCallback_cgo(bool *, Lib3MF_double, eLib3MFProgressIdentifier, Lib3MF_pvoid);
void Lib3MFWriteCallback_cgo(Lib3MF_uint64, Lib3MF_uint64, Lib3MF_pvoid);
void Lib3MFReadCallback_cgo(Lib3MF_uint64, Lib3MF_uint64, Lib3MF_pvoid);
void Lib3MFSeekCallback_cgo(Lib3MF_uint64, Lib3MF_pvoid);
*/
import "C"

import (
	"fmt"
	"runtime"
	"unsafe"
)

type ref = C.Lib3MFHandle

// PropertyType represents a Lib3MF enum.
type PropertyType int

const (
	PropertyType_NoPropertyType = 0
	PropertyType_BaseMaterial   = 1
	PropertyType_TexCoord       = 2
	PropertyType_Colors         = 3
	PropertyType_Composite      = 4
	PropertyType_Multi          = 5
)

// SlicesMeshResolution represents a Lib3MF enum.
type SlicesMeshResolution int

const (
	SlicesMeshResolution_Fullres = 0
	SlicesMeshResolution_Lowres  = 1
)

// ModelUnit represents a Lib3MF enum.
type ModelUnit int

const (
	ModelUnit_MicroMeter = 0
	ModelUnit_MilliMeter = 1
	ModelUnit_CentiMeter = 2
	ModelUnit_Inch       = 3
	ModelUnit_Foot       = 4
	ModelUnit_Meter      = 5
)

// ObjectType represents a Lib3MF enum.
type ObjectType int

const (
	ObjectType_Other        = 0
	ObjectType_Model        = 1
	ObjectType_Support      = 2
	ObjectType_SolidSupport = 3
)

// TextureType represents a Lib3MF enum.
type TextureType int

const (
	TextureType_Unknown = 0
	TextureType_PNG     = 1
	TextureType_JPEG    = 2
)

// TextureTileStyle represents a Lib3MF enum.
type TextureTileStyle int

const (
	TextureTileStyle_Wrap        = 0
	TextureTileStyle_Mirror      = 1
	TextureTileStyle_Clamp       = 2
	TextureTileStyle_NoTileStyle = 3
)

// TextureFilter represents a Lib3MF enum.
type TextureFilter int

const (
	TextureFilter_Auto    = 0
	TextureFilter_Linear  = 1
	TextureFilter_Nearest = 2
)

// BeamLatticeCapMode represents a Lib3MF enum.
type BeamLatticeCapMode int

const (
	BeamLatticeCapMode_Sphere     = 0
	BeamLatticeCapMode_HemiSphere = 1
	BeamLatticeCapMode_Butt       = 2
)

// BeamLatticeClipMode represents a Lib3MF enum.
type BeamLatticeClipMode int

const (
	BeamLatticeClipMode_NoClipMode = 0
	BeamLatticeClipMode_Inside     = 1
	BeamLatticeClipMode_Outside    = 2
)

// ProgressIdentifier represents a Lib3MF enum.
type ProgressIdentifier int

const (
	ProgressIdentifier_QUERYCANCELED        = 0
	ProgressIdentifier_DONE                 = 1
	ProgressIdentifier_CLEANUP              = 2
	ProgressIdentifier_READSTREAM           = 3
	ProgressIdentifier_EXTRACTOPCPACKAGE    = 4
	ProgressIdentifier_READNONROOTMODELS    = 5
	ProgressIdentifier_READROOTMODEL        = 6
	ProgressIdentifier_READRESOURCES        = 7
	ProgressIdentifier_READMESH             = 8
	ProgressIdentifier_READSLICES           = 9
	ProgressIdentifier_READBUILD            = 10
	ProgressIdentifier_READCUSTOMATTACHMENT = 11
	ProgressIdentifier_READTEXTURETACHMENTS = 12
	ProgressIdentifier_CREATEOPCPACKAGE     = 13
	ProgressIdentifier_WRITEMODELSTOSTREAM  = 14
	ProgressIdentifier_WRITEROOTMODEL       = 15
	ProgressIdentifier_WRITENONROOTMODELS   = 16
	ProgressIdentifier_WRITEATTACHMENTS     = 17
	ProgressIdentifier_WRITECONTENTTYPES    = 18
	ProgressIdentifier_WRITENOBJECTS        = 19
	ProgressIdentifier_WRITENODES           = 20
	ProgressIdentifier_WRITETRIANGLES       = 21
	ProgressIdentifier_WRITESLICES          = 22
)

// BlendMethod represents a Lib3MF enum.
type BlendMethod int

const (
	BlendMethod_NoBlendMethod = 0
	BlendMethod_Mix           = 1
	BlendMethod_Multiply      = 2
)

// Triangle represents a Lib3MF struct.
type Triangle struct {
	Indices [3]uint32
}

// TriangleProperties represents a Lib3MF struct.
type TriangleProperties struct {
	ResourceID  uint32
	PropertyIDs [3]uint32
}

// Position represents a Lib3MF struct.
type Position struct {
	Coordinates [3]float32
}

// Position2D represents a Lib3MF struct.
type Position2D struct {
	Coordinates [2]float32
}

// CompositeConstituent represents a Lib3MF struct.
type CompositeConstituent struct {
	PropertyID  uint32
	MixingRatio float64
}

// MultiPropertyLayer represents a Lib3MF struct.
type MultiPropertyLayer struct {
	ResourceID     uint32
	TheBlendMethod BlendMethod
}

// Tex2Coord represents a Lib3MF struct.
type Tex2Coord struct {
	U float64
	V float64
}

// Transform represents a Lib3MF struct.
type Transform struct {
	Fields [4][3]float32
}

// Box represents a Lib3MF struct.
type Box struct {
	MinCoordinate [3]float32
	MaxCoordinate [3]float32
}

// Color represents a Lib3MF struct.
type Color struct {
	Red   uint8
	Green uint8
	Blue  uint8
	Alpha uint8
}

// Beam represents a Lib3MF struct.
type Beam struct {
	Indices  [2]uint32
	Radii    [2]float64
	CapModes [2]BeamLatticeCapMode
}

// WrappedError is an error that wraps a Lib3MF error.
type WrappedError struct {
	Code    uint32
	Message string
}

func (e *WrappedError) Error() string {
	return fmt.Sprintf("lib3mf: %s (%d)", e.Message, e.Code)
}

func errorMessage(errorcode uint32) string {
	switch errorcode {
	case 1:
		return "NOTIMPLEMENTED"
	case 2:
		return "INVALIDPARAM"
	case 3:
		return "INVALIDCAST"
	case 4:
		return "BUFFERTOOSMALL"
	case 5:
		return "GENERICEXCEPTION"
	case 6:
		return "COULDNOTLOADLIBRARY"
	case 7:
		return "COULDNOTFINDLIBRARYEXPORT"
	case 8:
		return "INCOMPATIBLEBINARYVERSION"
	case 10:
		return "CALCULATIONABORTED"
	case 11:
		return "SHOULDNOTBECALLED"
	case 100:
		return "READERCLASSUNKNOWN"
	case 101:
		return "WRITERCLASSUNKNOWN"
	case 102:
		return "ITERATORINVALIDINDEX"
	case 103:
		return "INVALIDMODELRESOURCE"
	case 104:
		return "RESOURCENOTFOUND"
	case 105:
		return "INVALIDMODEL"
	case 106:
		return "INVALIDOBJECT"
	case 107:
		return "INVALIDMESHOBJECT"
	case 108:
		return "INVALIDCOMPONENTSOBJECT"
	case 109:
		return "INVALIDCOMPONENT"
	case 110:
		return "INVALIDBUILDITEM"
	case 111:
		return "INVALIDBASEMATERIALGROUP"
	case 112:
		return "INVALIDSLICESTACKRESOURCE"
	case 113:
		return "INVALIDTEXTURERESOURCE"
	case 114:
		return "INVALIDCOLORGROUP"
	case 115:
		return "INVALIDTEXTURE2DGROUP"
	case 116:
		return "INVALIDCOMPOSITEMATERIALS"
	case 117:
		return "INVALIDMULTIPROPERTYGROUP"
	case 120:
		return "INVALIDRESOURCEINDEX"
	case 121:
		return "ATTACHMENTNOTFOUND"
	case 130:
		return "FORBIDDENCYCLICREFERENCE"
	case 131:
		return "INVALIDATTACHMENTSTREAM"
	case 132:
		return "INVALIDPROPERTYCOUNT"
	case 140:
		return "UNKOWNPROGRESSIDENTIFIER"
	case 2000:
		return "BEAMLATTICE_INVALID_OBJECTTYPE"
	default:
		return "unknown"
	}
}

func makeError(errorcode uint32) error {
	return &WrappedError{errorcode, errorMessage(uint32(errorcode))}
}

// ProgressCallbackFunc a callback function.
type ProgressCallbackFunc = func(abort *bool, progressValue float64, progressIdentifier ProgressIdentifier, userData interface{})

var progressCallbackFunc ProgressCallbackFunc

//export progressCallback
func progressCallback(abort *C.bool, progressValue C.double, progressIdentifier C.eLib3MFProgressIdentifier, userData C.Lib3MF_pvoid) {
	if progressCallbackFunc == nil {
		return
	}
	progressCallbackFunc((*bool)(abort), float64(progressValue), ProgressIdentifier(progressIdentifier), *(*interface{})(unsafe.Pointer(userData)))
}

// WriteCallbackFunc callback to call for writing a data chunk.
type WriteCallbackFunc = func(byteData uint64, numBytes uint64, userData interface{})

var writeCallbackFunc WriteCallbackFunc

//export writeCallback
func writeCallback(byteData C.uint64_t, numBytes C.uint64_t, userData C.Lib3MF_pvoid) {
	if writeCallbackFunc == nil {
		return
	}
	writeCallbackFunc(uint64(byteData), uint64(numBytes), *(*interface{})(unsafe.Pointer(userData)))
}

// ReadCallbackFunc callback to call for reading a data chunk.
type ReadCallbackFunc = func(byteData uint64, numBytes uint64, userData interface{})

var readCallbackFunc ReadCallbackFunc

//export readCallback
func readCallback(byteData C.uint64_t, numBytes C.uint64_t, userData C.Lib3MF_pvoid) {
	if readCallbackFunc == nil {
		return
	}
	readCallbackFunc(uint64(byteData), uint64(numBytes), *(*interface{})(unsafe.Pointer(userData)))
}

// SeekCallbackFunc callback to call for seeking in the stream.
type SeekCallbackFunc = func(position uint64, userData interface{})

var seekCallbackFunc SeekCallbackFunc

//export seekCallback
func seekCallback(position C.uint64_t, userData C.Lib3MF_pvoid) {
	if seekCallbackFunc == nil {
		return
	}
	seekCallbackFunc(uint64(position), *(*interface{})(unsafe.Pointer(userData)))
}

// Base represents a Lib3MF class.
type Base struct {
	_     [0]func() // uncomparable; to make == not compile
	ref   ref       // identifies a C value, see ref type
	gcPtr *ref      // used to trigger the finalizer when the Value is not referenced any more
}

// NewBase creates a new Base.
// The wrapped C pointer will be freed when the Go pointer is finalized,
// but one can release it manually calling Release.
func NewBase(r ref) Base {
	gcPtr := new(ref)
	*gcPtr = r
	runtime.SetFinalizer(gcPtr, releaseC)
	return Base{ref: r, gcPtr: gcPtr}
}

// Release releases the C pointer.
func (inst Base) Release() error {
	err := Release(inst)
	*inst.gcPtr = nil
	return err
}

// Equal reports whether inst and w refer to the same C pointer.
func (inst Base) Equal(w Base) bool {
	return inst.ref == w.ref
}

// Writer represents a Lib3MF class.
type Writer struct {
	Base
}

func newWriter(r ref) Writer {
	return Writer{NewBase(r)}
}

// WriteToFile writes out the model as file. The file type is specified by the Model Writer class.
func (inst Writer) WriteToFile(filename string) error {
	ret := C.lib3mf_writer_writetofile(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(filename)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetStreamSize retrieves the size of the full 3MF file stream.
func (inst Writer) GetStreamSize() (uint64, error) {
	var streamSize C.uint64_t
	ret := C.lib3mf_writer_getstreamsize(inst.ref, &streamSize)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(streamSize), nil
}

// WriteToBuffer writes out the 3MF file into a memory buffer.
func (inst Writer) WriteToBuffer(buffer []uint8) ([]uint8, error) {
	var neededforbuffer C.uint64_t
	ret := C.lib3mf_writer_writetobuffer(inst.ref, 0, &neededforbuffer, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(buffer) < int(neededforbuffer) {
		buffer = append(buffer, make([]uint8, int(neededforbuffer)-len(buffer))...)
	}
	ret = C.lib3mf_writer_writetobuffer(inst.ref, neededforbuffer, nil, (*C.uint8_t)(unsafe.Pointer(&buffer[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return buffer[:int(neededforbuffer)], nil
}

// WriteToCallback writes out the model and passes the data to a provided callback function. The file type is specified by the Model Writer class.
func (inst Writer) WriteToCallback(theWriteCallback WriteCallbackFunc, theSeekCallback SeekCallbackFunc, userData interface{}) error {
	ret := C.lib3mf_writer_writetocallback(inst.ref, (C.Lib3MFWriteCallback)(unsafe.Pointer(C.Lib3MFWriteCallback_cgo)), (C.Lib3MFSeekCallback)(unsafe.Pointer(C.Lib3MFSeekCallback_cgo)), (C.Lib3MF_pvoid)(unsafe.Pointer(&userData)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	writeCallbackFunc = theWriteCallback
	seekCallbackFunc = theSeekCallback
	return nil
}

// SetProgressCallback set the progress callback for calls to this writer.
func (inst Writer) SetProgressCallback(progressCallback ProgressCallbackFunc, userData interface{}) error {
	ret := C.lib3mf_writer_setprogresscallback(inst.ref, (C.Lib3MFProgressCallback)(unsafe.Pointer(C.Lib3MFProgressCallback_cgo)), (C.Lib3MF_pvoid)(unsafe.Pointer(&userData)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	progressCallbackFunc = progressCallback
	return nil
}

// GetDecimalPrecision returns the number of digits after the decimal point to be written in each vertex coordinate-value.
func (inst Writer) GetDecimalPrecision() (uint32, error) {
	var decimalPrecision C.uint32_t
	ret := C.lib3mf_writer_getdecimalprecision(inst.ref, &decimalPrecision)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(decimalPrecision), nil
}

// SetDecimalPrecision sets the number of digits after the decimal point to be written in each vertex coordinate-value.
func (inst Writer) SetDecimalPrecision(decimalPrecision uint32) error {
	ret := C.lib3mf_writer_setdecimalprecision(inst.ref, C.uint32_t(decimalPrecision))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// Reader represents a Lib3MF class.
type Reader struct {
	Base
}

func newReader(r ref) Reader {
	return Reader{NewBase(r)}
}

// ReadFromFile reads a model from a file. The file type is specified by the Model Reader class.
func (inst Reader) ReadFromFile(filename string) error {
	ret := C.lib3mf_reader_readfromfile(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(filename)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// ReadFromBuffer reads a model from a memory buffer.
func (inst Reader) ReadFromBuffer(buffer []uint8) error {
	ret := C.lib3mf_reader_readfrombuffer(inst.ref, C.uint64_t(len(buffer)), (*C.uint8_t)(unsafe.Pointer(&buffer[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// ReadFromCallback reads a model and from the data provided by a callback function.
func (inst Reader) ReadFromCallback(theReadCallback ReadCallbackFunc, streamSize uint64, theSeekCallback SeekCallbackFunc, userData interface{}) error {
	ret := C.lib3mf_reader_readfromcallback(inst.ref, (C.Lib3MFReadCallback)(unsafe.Pointer(C.Lib3MFReadCallback_cgo)), C.uint64_t(streamSize), (C.Lib3MFSeekCallback)(unsafe.Pointer(C.Lib3MFSeekCallback_cgo)), (C.Lib3MF_pvoid)(unsafe.Pointer(&userData)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	readCallbackFunc = theReadCallback
	seekCallbackFunc = theSeekCallback
	return nil
}

// SetProgressCallback set the progress callback for calls to this writer.
func (inst Reader) SetProgressCallback(progressCallback ProgressCallbackFunc, userData interface{}) error {
	ret := C.lib3mf_reader_setprogresscallback(inst.ref, (C.Lib3MFProgressCallback)(unsafe.Pointer(C.Lib3MFProgressCallback_cgo)), (C.Lib3MF_pvoid)(unsafe.Pointer(&userData)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	progressCallbackFunc = progressCallback
	return nil
}

// AddRelationToRead adds a relationship type which shall be read as attachment in memory while loading.
func (inst Reader) AddRelationToRead(relationShipType string) error {
	ret := C.lib3mf_reader_addrelationtoread(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(relationShipType)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// RemoveRelationToRead removes a relationship type which shall be read as attachment in memory while loading.
func (inst Reader) RemoveRelationToRead(relationShipType string) error {
	ret := C.lib3mf_reader_removerelationtoread(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(relationShipType)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// SetStrictModeActive activates (deactivates) the strict mode of the reader.
func (inst Reader) SetStrictModeActive(strictModeActive bool) error {
	ret := C.lib3mf_reader_setstrictmodeactive(inst.ref, C.bool(strictModeActive))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetStrictModeActive queries whether the strict mode of the reader is active or not.
func (inst Reader) GetStrictModeActive() (bool, error) {
	var strictModeActive C.bool
	ret := C.lib3mf_reader_getstrictmodeactive(inst.ref, &strictModeActive)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(strictModeActive), nil
}

// GetWarning returns Warning and Error Information of the read process.
func (inst Reader) GetWarning(index uint32) (uint32, string, error) {
	var errorCode C.uint32_t
	var neededforwarning C.uint32_t
	var filledinwarning C.uint32_t
	ret := C.lib3mf_reader_getwarning(inst.ref, C.uint32_t(index), &errorCode, 0, &neededforwarning, nil)
	if ret != 0 {
		return 0, "", makeError(uint32(ret))
	}
	bufferSizewarning := neededforwarning
	bufferwarning := make([]byte, bufferSizewarning)
	ret = C.lib3mf_reader_getwarning(inst.ref, C.uint32_t(index), &errorCode, bufferSizewarning, &filledinwarning, (*C.char)(unsafe.Pointer(&bufferwarning[0])))
	if ret != 0 {
		return 0, "", makeError(uint32(ret))
	}
	return uint32(errorCode), string(bufferwarning[:(filledinwarning - 1)]), nil
}

// GetWarningCount returns Warning and Error Count of the read process.
func (inst Reader) GetWarningCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_reader_getwarningcount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// Resource represents a Lib3MF class.
type Resource struct {
	Base
}

func newResource(r ref) Resource {
	return Resource{NewBase(r)}
}

// GetResourceID retrieves the resource id of the resource instance.
func (inst Resource) GetResourceID() (uint32, error) {
	var id C.uint32_t
	ret := C.lib3mf_resource_getresourceid(inst.ref, &id)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(id), nil
}

// ResourceIterator represents a Lib3MF class.
type ResourceIterator struct {
	Base
}

func newResourceIterator(r ref) ResourceIterator {
	return ResourceIterator{NewBase(r)}
}

// MoveNext iterates to the next resource in the list.
func (inst ResourceIterator) MoveNext() (bool, error) {
	var hasNext C.bool
	ret := C.lib3mf_resourceiterator_movenext(inst.ref, &hasNext)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(hasNext), nil
}

// MovePrevious iterates to the previous resource in the list.
func (inst ResourceIterator) MovePrevious() (bool, error) {
	var hasPrevious C.bool
	ret := C.lib3mf_resourceiterator_moveprevious(inst.ref, &hasPrevious)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(hasPrevious), nil
}

// GetCurrent returns the resource the iterator points at.
func (inst ResourceIterator) GetCurrent() (Resource, error) {
	var resource ref
	ret := C.lib3mf_resourceiterator_getcurrent(inst.ref, &resource)
	if ret != 0 {
		return Resource{}, makeError(uint32(ret))
	}
	return newResource(resource), nil
}

// Clone creates a new resource iterator with the same resource list.
func (inst ResourceIterator) Clone() (ResourceIterator, error) {
	var outResourceIterator ref
	ret := C.lib3mf_resourceiterator_clone(inst.ref, &outResourceIterator)
	if ret != 0 {
		return ResourceIterator{}, makeError(uint32(ret))
	}
	return newResourceIterator(outResourceIterator), nil
}

// Count returns the number of resoucres the iterator captures.
func (inst ResourceIterator) Count() (uint64, error) {
	var count C.uint64_t
	ret := C.lib3mf_resourceiterator_count(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(count), nil
}

// SliceStackIterator represents a Lib3MF class.
type SliceStackIterator struct {
	ResourceIterator
}

func newSliceStackIterator(r ref) SliceStackIterator {
	return SliceStackIterator{newResourceIterator(r)}
}

// GetCurrentSliceStack returns the SliceStack the iterator points at.
func (inst SliceStackIterator) GetCurrentSliceStack() (SliceStack, error) {
	var resource ref
	ret := C.lib3mf_slicestackiterator_getcurrentslicestack(inst.ref, &resource)
	if ret != 0 {
		return SliceStack{}, makeError(uint32(ret))
	}
	return newSliceStack(resource), nil
}

// ObjectIterator represents a Lib3MF class.
type ObjectIterator struct {
	ResourceIterator
}

func newObjectIterator(r ref) ObjectIterator {
	return ObjectIterator{newResourceIterator(r)}
}

// GetCurrentObject returns the Object the iterator points at.
func (inst ObjectIterator) GetCurrentObject() (Object, error) {
	var resource ref
	ret := C.lib3mf_objectiterator_getcurrentobject(inst.ref, &resource)
	if ret != 0 {
		return Object{}, makeError(uint32(ret))
	}
	return newObject(resource), nil
}

// MeshObjectIterator represents a Lib3MF class.
type MeshObjectIterator struct {
	ResourceIterator
}

func newMeshObjectIterator(r ref) MeshObjectIterator {
	return MeshObjectIterator{newResourceIterator(r)}
}

// GetCurrentMeshObject returns the MeshObject the iterator points at.
func (inst MeshObjectIterator) GetCurrentMeshObject() (MeshObject, error) {
	var resource ref
	ret := C.lib3mf_meshobjectiterator_getcurrentmeshobject(inst.ref, &resource)
	if ret != 0 {
		return MeshObject{}, makeError(uint32(ret))
	}
	return newMeshObject(resource), nil
}

// ComponentsObjectIterator represents a Lib3MF class.
type ComponentsObjectIterator struct {
	ResourceIterator
}

func newComponentsObjectIterator(r ref) ComponentsObjectIterator {
	return ComponentsObjectIterator{newResourceIterator(r)}
}

// GetCurrentComponentsObject returns the ComponentsObject the iterator points at.
func (inst ComponentsObjectIterator) GetCurrentComponentsObject() (ComponentsObject, error) {
	var resource ref
	ret := C.lib3mf_componentsobjectiterator_getcurrentcomponentsobject(inst.ref, &resource)
	if ret != 0 {
		return ComponentsObject{}, makeError(uint32(ret))
	}
	return newComponentsObject(resource), nil
}

// Texture2DIterator represents a Lib3MF class.
type Texture2DIterator struct {
	ResourceIterator
}

func newTexture2DIterator(r ref) Texture2DIterator {
	return Texture2DIterator{newResourceIterator(r)}
}

// GetCurrentTexture2D returns the Texture2D the iterator points at.
func (inst Texture2DIterator) GetCurrentTexture2D() (Texture2D, error) {
	var resource ref
	ret := C.lib3mf_texture2diterator_getcurrenttexture2d(inst.ref, &resource)
	if ret != 0 {
		return Texture2D{}, makeError(uint32(ret))
	}
	return newTexture2D(resource), nil
}

// BaseMaterialGroupIterator represents a Lib3MF class.
type BaseMaterialGroupIterator struct {
	ResourceIterator
}

func newBaseMaterialGroupIterator(r ref) BaseMaterialGroupIterator {
	return BaseMaterialGroupIterator{newResourceIterator(r)}
}

// GetCurrentBaseMaterialGroup returns the MaterialGroup the iterator points at.
func (inst BaseMaterialGroupIterator) GetCurrentBaseMaterialGroup() (BaseMaterialGroup, error) {
	var resource ref
	ret := C.lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup(inst.ref, &resource)
	if ret != 0 {
		return BaseMaterialGroup{}, makeError(uint32(ret))
	}
	return newBaseMaterialGroup(resource), nil
}

// ColorGroupIterator represents a Lib3MF class.
type ColorGroupIterator struct {
	ResourceIterator
}

func newColorGroupIterator(r ref) ColorGroupIterator {
	return ColorGroupIterator{newResourceIterator(r)}
}

// GetCurrentColorGroup returns the ColorGroup the iterator points at.
func (inst ColorGroupIterator) GetCurrentColorGroup() (ColorGroup, error) {
	var resource ref
	ret := C.lib3mf_colorgroupiterator_getcurrentcolorgroup(inst.ref, &resource)
	if ret != 0 {
		return ColorGroup{}, makeError(uint32(ret))
	}
	return newColorGroup(resource), nil
}

// Texture2DGroupIterator represents a Lib3MF class.
type Texture2DGroupIterator struct {
	ResourceIterator
}

func newTexture2DGroupIterator(r ref) Texture2DGroupIterator {
	return Texture2DGroupIterator{newResourceIterator(r)}
}

// GetCurrentTexture2DGroup returns the Texture2DGroup the iterator points at.
func (inst Texture2DGroupIterator) GetCurrentTexture2DGroup() (Texture2DGroup, error) {
	var resource ref
	ret := C.lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup(inst.ref, &resource)
	if ret != 0 {
		return Texture2DGroup{}, makeError(uint32(ret))
	}
	return newTexture2DGroup(resource), nil
}

// CompositeMaterialsIterator represents a Lib3MF class.
type CompositeMaterialsIterator struct {
	ResourceIterator
}

func newCompositeMaterialsIterator(r ref) CompositeMaterialsIterator {
	return CompositeMaterialsIterator{newResourceIterator(r)}
}

// GetCurrentCompositeMaterials returns the CompositeMaterials the iterator points at.
func (inst CompositeMaterialsIterator) GetCurrentCompositeMaterials() (CompositeMaterials, error) {
	var resource ref
	ret := C.lib3mf_compositematerialsiterator_getcurrentcompositematerials(inst.ref, &resource)
	if ret != 0 {
		return CompositeMaterials{}, makeError(uint32(ret))
	}
	return newCompositeMaterials(resource), nil
}

// MultiPropertyGroupIterator represents a Lib3MF class.
type MultiPropertyGroupIterator struct {
	ResourceIterator
}

func newMultiPropertyGroupIterator(r ref) MultiPropertyGroupIterator {
	return MultiPropertyGroupIterator{newResourceIterator(r)}
}

// GetCurrentMultiPropertyGroup returns the MultiPropertyGroup the iterator points at.
func (inst MultiPropertyGroupIterator) GetCurrentMultiPropertyGroup() (MultiPropertyGroup, error) {
	var resource ref
	ret := C.lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup(inst.ref, &resource)
	if ret != 0 {
		return MultiPropertyGroup{}, makeError(uint32(ret))
	}
	return newMultiPropertyGroup(resource), nil
}

// MetaData represents a Lib3MF class.
type MetaData struct {
	Base
}

func newMetaData(r ref) MetaData {
	return MetaData{NewBase(r)}
}

// GetNameSpace returns the namespace URL of the metadata.
func (inst MetaData) GetNameSpace() (string, error) {
	var neededfornameSpace C.uint32_t
	var filledinnameSpace C.uint32_t
	ret := C.lib3mf_metadata_getnamespace(inst.ref, 0, &neededfornameSpace, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizenameSpace := neededfornameSpace
	buffernameSpace := make([]byte, bufferSizenameSpace)
	ret = C.lib3mf_metadata_getnamespace(inst.ref, bufferSizenameSpace, &filledinnameSpace, (*C.char)(unsafe.Pointer(&buffernameSpace[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffernameSpace[:(filledinnameSpace - 1)]), nil
}

// SetNameSpace sets a new namespace URL of the metadata.
func (inst MetaData) SetNameSpace(nameSpace string) error {
	ret := C.lib3mf_metadata_setnamespace(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(nameSpace)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetName returns the name of a metadata.
func (inst MetaData) GetName() (string, error) {
	var neededforname C.uint32_t
	var filledinname C.uint32_t
	ret := C.lib3mf_metadata_getname(inst.ref, 0, &neededforname, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizename := neededforname
	buffername := make([]byte, bufferSizename)
	ret = C.lib3mf_metadata_getname(inst.ref, bufferSizename, &filledinname, (*C.char)(unsafe.Pointer(&buffername[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffername[:(filledinname - 1)]), nil
}

// SetName sets a new name of a metadata.
func (inst MetaData) SetName(name string) error {
	ret := C.lib3mf_metadata_setname(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(name)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetKey returns the (namespace+name) of a metadata.
func (inst MetaData) GetKey() (string, error) {
	var neededforkey C.uint32_t
	var filledinkey C.uint32_t
	ret := C.lib3mf_metadata_getkey(inst.ref, 0, &neededforkey, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizekey := neededforkey
	bufferkey := make([]byte, bufferSizekey)
	ret = C.lib3mf_metadata_getkey(inst.ref, bufferSizekey, &filledinkey, (*C.char)(unsafe.Pointer(&bufferkey[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferkey[:(filledinkey - 1)]), nil
}

// GetMustPreserve returns, whether a metadata must be preserved.
func (inst MetaData) GetMustPreserve() (bool, error) {
	var mustPreserve C.bool
	ret := C.lib3mf_metadata_getmustpreserve(inst.ref, &mustPreserve)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(mustPreserve), nil
}

// SetMustPreserve sets whether a metadata must be preserved.
func (inst MetaData) SetMustPreserve(mustPreserve bool) error {
	ret := C.lib3mf_metadata_setmustpreserve(inst.ref, C.bool(mustPreserve))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetType returns the type of a metadata.
func (inst MetaData) GetType() (string, error) {
	var neededfor_type C.uint32_t
	var filledin_type C.uint32_t
	ret := C.lib3mf_metadata_gettype(inst.ref, 0, &neededfor_type, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSize_type := neededfor_type
	buffer_type := make([]byte, bufferSize_type)
	ret = C.lib3mf_metadata_gettype(inst.ref, bufferSize_type, &filledin_type, (*C.char)(unsafe.Pointer(&buffer_type[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffer_type[:(filledin_type - 1)]), nil
}

// SetType sets a new type of a metadata. This must be a simple XML type.
func (inst MetaData) SetType(_type string) error {
	ret := C.lib3mf_metadata_settype(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(_type)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetValue returns the value of the metadata.
func (inst MetaData) GetValue() (string, error) {
	var neededforvalue C.uint32_t
	var filledinvalue C.uint32_t
	ret := C.lib3mf_metadata_getvalue(inst.ref, 0, &neededforvalue, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizevalue := neededforvalue
	buffervalue := make([]byte, bufferSizevalue)
	ret = C.lib3mf_metadata_getvalue(inst.ref, bufferSizevalue, &filledinvalue, (*C.char)(unsafe.Pointer(&buffervalue[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffervalue[:(filledinvalue - 1)]), nil
}

// SetValue sets a new value of the metadata.
func (inst MetaData) SetValue(value string) error {
	ret := C.lib3mf_metadata_setvalue(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(value)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// MetaDataGroup represents a Lib3MF class.
type MetaDataGroup struct {
	Base
}

func newMetaDataGroup(r ref) MetaDataGroup {
	return MetaDataGroup{NewBase(r)}
}

// GetMetaDataCount returns the number of metadata in this metadatagroup.
func (inst MetaDataGroup) GetMetaDataCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_metadatagroup_getmetadatacount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// GetMetaData returns a metadata value within this metadatagroup.
func (inst MetaDataGroup) GetMetaData(index uint32) (MetaData, error) {
	var metaData ref
	ret := C.lib3mf_metadatagroup_getmetadata(inst.ref, C.uint32_t(index), &metaData)
	if ret != 0 {
		return MetaData{}, makeError(uint32(ret))
	}
	return newMetaData(metaData), nil
}

// GetMetaDataByKey returns a metadata value within this metadatagroup.
func (inst MetaDataGroup) GetMetaDataByKey(nameSpace string, name string) (MetaData, error) {
	var metaData ref
	ret := C.lib3mf_metadatagroup_getmetadatabykey(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(nameSpace)[0])), (*C.char)(unsafe.Pointer(&[]byte(name)[0])), &metaData)
	if ret != 0 {
		return MetaData{}, makeError(uint32(ret))
	}
	return newMetaData(metaData), nil
}

// RemoveMetaDataByIndex removes metadata by index from the model.
func (inst MetaDataGroup) RemoveMetaDataByIndex(index uint32) error {
	ret := C.lib3mf_metadatagroup_removemetadatabyindex(inst.ref, C.uint32_t(index))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// RemoveMetaData removes metadata from the model.
func (inst MetaDataGroup) RemoveMetaData(theMetaData MetaData) error {
	ret := C.lib3mf_metadatagroup_removemetadata(inst.ref, theMetaData.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// AddMetaData adds a new metadata to this metadatagroup.
func (inst MetaDataGroup) AddMetaData(nameSpace string, name string, value string, _type string, mustPreserve bool) (MetaData, error) {
	var metaData ref
	ret := C.lib3mf_metadatagroup_addmetadata(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(nameSpace)[0])), (*C.char)(unsafe.Pointer(&[]byte(name)[0])), (*C.char)(unsafe.Pointer(&[]byte(value)[0])), (*C.char)(unsafe.Pointer(&[]byte(_type)[0])), C.bool(mustPreserve), &metaData)
	if ret != 0 {
		return MetaData{}, makeError(uint32(ret))
	}
	return newMetaData(metaData), nil
}

// Object represents a Lib3MF class.
type Object struct {
	Resource
}

func newObject(r ref) Object {
	return Object{newResource(r)}
}

// GetType retrieves an object's type.
func (inst Object) GetType() (ObjectType, error) {
	var objectType C.eLib3MFObjectType
	ret := C.lib3mf_object_gettype(inst.ref, &objectType)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return ObjectType(objectType), nil
}

// SetType sets an object's type.
func (inst Object) SetType(objectType ObjectType) error {
	ret := C.lib3mf_object_settype(inst.ref, C.eLib3MFObjectType(objectType))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetName retrieves an object's name.
func (inst Object) GetName() (string, error) {
	var neededforname C.uint32_t
	var filledinname C.uint32_t
	ret := C.lib3mf_object_getname(inst.ref, 0, &neededforname, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizename := neededforname
	buffername := make([]byte, bufferSizename)
	ret = C.lib3mf_object_getname(inst.ref, bufferSizename, &filledinname, (*C.char)(unsafe.Pointer(&buffername[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffername[:(filledinname - 1)]), nil
}

// SetName sets an object's name string.
func (inst Object) SetName(name string) error {
	ret := C.lib3mf_object_setname(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(name)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetPartNumber retrieves an object's part number.
func (inst Object) GetPartNumber() (string, error) {
	var neededforpartNumber C.uint32_t
	var filledinpartNumber C.uint32_t
	ret := C.lib3mf_object_getpartnumber(inst.ref, 0, &neededforpartNumber, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizepartNumber := neededforpartNumber
	bufferpartNumber := make([]byte, bufferSizepartNumber)
	ret = C.lib3mf_object_getpartnumber(inst.ref, bufferSizepartNumber, &filledinpartNumber, (*C.char)(unsafe.Pointer(&bufferpartNumber[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferpartNumber[:(filledinpartNumber - 1)]), nil
}

// SetPartNumber sets an objects partnumber string.
func (inst Object) SetPartNumber(partNumber string) error {
	ret := C.lib3mf_object_setpartnumber(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(partNumber)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// IsMeshObject retrieves, if an object is a mesh object.
func (inst Object) IsMeshObject() (bool, error) {
	var isMeshObject C.bool
	ret := C.lib3mf_object_ismeshobject(inst.ref, &isMeshObject)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(isMeshObject), nil
}

// IsComponentsObject retrieves, if an object is a components object.
func (inst Object) IsComponentsObject() (bool, error) {
	var isComponentsObject C.bool
	ret := C.lib3mf_object_iscomponentsobject(inst.ref, &isComponentsObject)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(isComponentsObject), nil
}

// IsValid retrieves, if the object is valid according to the core spec. For mesh objects, we distinguish between the type attribute of the object:In case of object type other, this always means false.In case of object type model or solidsupport, this means, if the mesh suffices all requirements of the core spec chapter 4.1.In case of object type support or surface, this always means true.A component objects is valid if and only if it contains at least one component and all child components are valid objects.
func (inst Object) IsValid() (bool, error) {
	var isValid C.bool
	ret := C.lib3mf_object_isvalid(inst.ref, &isValid)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(isValid), nil
}

// SetAttachmentAsThumbnail use an existing attachment as thumbnail for this object.
func (inst Object) SetAttachmentAsThumbnail(attachment Attachment) error {
	ret := C.lib3mf_object_setattachmentasthumbnail(inst.ref, attachment.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetThumbnailAttachment get the attachment containing the object thumbnail.
func (inst Object) GetThumbnailAttachment() (*Attachment, error) {
	var attachment ref
	ret := C.lib3mf_object_getthumbnailattachment(inst.ref, &attachment)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	var _attachmentPtr *Attachment
	if attachment == nil {
		_attachmentPtrVal := newAttachment(attachment)
		_attachmentPtr = &_attachmentPtrVal
	}
	return _attachmentPtr, nil
}

// ClearThumbnailAttachment clears the attachment. The attachment instance is not removed from the package.
func (inst Object) ClearThumbnailAttachment() error {
	ret := C.lib3mf_object_clearthumbnailattachment(inst.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetOutbox returns the outbox of a build item.
func (inst Object) GetOutbox() (Box, error) {
	var outbox C.sLib3MFBox
	ret := C.lib3mf_object_getoutbox(inst.ref, &outbox)
	if ret != 0 {
		return Box{}, makeError(uint32(ret))
	}
	return *(*Box)(unsafe.Pointer(&outbox)), nil
}

// GetUUID retrieves an object's uuid string (see production extension specification).
func (inst Object) GetUUID() (bool, string, error) {
	var hasUUID C.bool
	var neededforuUID C.uint32_t
	var filledinuUID C.uint32_t
	ret := C.lib3mf_object_getuuid(inst.ref, &hasUUID, 0, &neededforuUID, nil)
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	bufferSizeuUID := neededforuUID
	bufferuUID := make([]byte, bufferSizeuUID)
	ret = C.lib3mf_object_getuuid(inst.ref, &hasUUID, bufferSizeuUID, &filledinuUID, (*C.char)(unsafe.Pointer(&bufferuUID[0])))
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	return bool(hasUUID), string(bufferuUID[:(filledinuUID - 1)]), nil
}

// SetUUID sets a build object's uuid string (see production extension specification).
func (inst Object) SetUUID(uUID string) error {
	ret := C.lib3mf_object_setuuid(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(uUID)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetMetaDataGroup returns the metadatagroup of this object.
func (inst Object) GetMetaDataGroup() (MetaDataGroup, error) {
	var metaDataGroup ref
	ret := C.lib3mf_object_getmetadatagroup(inst.ref, &metaDataGroup)
	if ret != 0 {
		return MetaDataGroup{}, makeError(uint32(ret))
	}
	return newMetaDataGroup(metaDataGroup), nil
}

// SetSlicesMeshResolution set the meshresolution of the mesh object.
func (inst Object) SetSlicesMeshResolution(meshResolution SlicesMeshResolution) error {
	ret := C.lib3mf_object_setslicesmeshresolution(inst.ref, C.eLib3MFSlicesMeshResolution(meshResolution))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetSlicesMeshResolution get the meshresolution of the mesh object.
func (inst Object) GetSlicesMeshResolution() (SlicesMeshResolution, error) {
	var meshResolution C.eLib3MFSlicesMeshResolution
	ret := C.lib3mf_object_getslicesmeshresolution(inst.ref, &meshResolution)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return SlicesMeshResolution(meshResolution), nil
}

// HasSlices returns whether the Object has a slice stack. If Recursive is true, also checks whether any references object has a slice stack.
func (inst Object) HasSlices(recursive bool) (bool, error) {
	var hasSlices C.bool
	ret := C.lib3mf_object_hasslices(inst.ref, C.bool(recursive), &hasSlices)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(hasSlices), nil
}

// ClearSliceStack unlinks the attached slicestack from this object. If no slice stack is attached, do noting.
func (inst Object) ClearSliceStack() error {
	ret := C.lib3mf_object_clearslicestack(inst.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetSliceStack get the Slicestack attached to the object.
func (inst Object) GetSliceStack() (SliceStack, error) {
	var sliceStackInstance ref
	ret := C.lib3mf_object_getslicestack(inst.ref, &sliceStackInstance)
	if ret != 0 {
		return SliceStack{}, makeError(uint32(ret))
	}
	return newSliceStack(sliceStackInstance), nil
}

// AssignSliceStack assigns a slicestack to the object.
func (inst Object) AssignSliceStack(sliceStackInstance SliceStack) error {
	ret := C.lib3mf_object_assignslicestack(inst.ref, sliceStackInstance.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// MeshObject represents a Lib3MF class.
type MeshObject struct {
	Object
}

func newMeshObject(r ref) MeshObject {
	return MeshObject{newObject(r)}
}

// GetVertexCount returns the vertex count of a mesh object.
func (inst MeshObject) GetVertexCount() (uint32, error) {
	var vertexCount C.uint32_t
	ret := C.lib3mf_meshobject_getvertexcount(inst.ref, &vertexCount)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(vertexCount), nil
}

// GetTriangleCount returns the triangle count of a mesh object.
func (inst MeshObject) GetTriangleCount() (uint32, error) {
	var vertexCount C.uint32_t
	ret := C.lib3mf_meshobject_gettrianglecount(inst.ref, &vertexCount)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(vertexCount), nil
}

// GetVertex returns the vertex count of a mesh object.
func (inst MeshObject) GetVertex(index uint32) (Position, error) {
	var coordinates C.sLib3MFPosition
	ret := C.lib3mf_meshobject_getvertex(inst.ref, C.uint32_t(index), &coordinates)
	if ret != 0 {
		return Position{}, makeError(uint32(ret))
	}
	return *(*Position)(unsafe.Pointer(&coordinates)), nil
}

// SetVertex sets the coordinates of a single vertex of a mesh object.
func (inst MeshObject) SetVertex(index uint32, coordinates Position) error {
	ret := C.lib3mf_meshobject_setvertex(inst.ref, C.uint32_t(index), (*C.sLib3MFPosition)(unsafe.Pointer(&coordinates)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// AddVertex adds a single vertex to a mesh object.
func (inst MeshObject) AddVertex(coordinates Position) (uint32, error) {
	var newIndex C.uint32_t
	ret := C.lib3mf_meshobject_addvertex(inst.ref, (*C.sLib3MFPosition)(unsafe.Pointer(&coordinates)), &newIndex)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(newIndex), nil
}

// GetVertices obtains all vertex positions of a mesh object.
func (inst MeshObject) GetVertices(vertices []Position) ([]Position, error) {
	var neededforvertices C.uint64_t
	ret := C.lib3mf_meshobject_getvertices(inst.ref, 0, &neededforvertices, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(vertices) < int(neededforvertices) {
		vertices = append(vertices, make([]Position, int(neededforvertices)-len(vertices))...)
	}
	ret = C.lib3mf_meshobject_getvertices(inst.ref, neededforvertices, nil, (*C.sLib3MFPosition)(unsafe.Pointer(&vertices[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return vertices[:int(neededforvertices)], nil
}

// GetTriangle returns indices of a single triangle of a mesh object.
func (inst MeshObject) GetTriangle(index uint32) (Triangle, error) {
	var indices C.sLib3MFTriangle
	ret := C.lib3mf_meshobject_gettriangle(inst.ref, C.uint32_t(index), &indices)
	if ret != 0 {
		return Triangle{}, makeError(uint32(ret))
	}
	return *(*Triangle)(unsafe.Pointer(&indices)), nil
}

// SetTriangle sets the indices of a single triangle of a mesh object.
func (inst MeshObject) SetTriangle(index uint32, indices Triangle) error {
	ret := C.lib3mf_meshobject_settriangle(inst.ref, C.uint32_t(index), (*C.sLib3MFTriangle)(unsafe.Pointer(&indices)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// AddTriangle adds a single triangle to a mesh object.
func (inst MeshObject) AddTriangle(indices Triangle) (uint32, error) {
	var newIndex C.uint32_t
	ret := C.lib3mf_meshobject_addtriangle(inst.ref, (*C.sLib3MFTriangle)(unsafe.Pointer(&indices)), &newIndex)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(newIndex), nil
}

// GetTriangleIndices get all triangles of a mesh object.
func (inst MeshObject) GetTriangleIndices(indices []Triangle) ([]Triangle, error) {
	var neededforindices C.uint64_t
	ret := C.lib3mf_meshobject_gettriangleindices(inst.ref, 0, &neededforindices, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(indices) < int(neededforindices) {
		indices = append(indices, make([]Triangle, int(neededforindices)-len(indices))...)
	}
	ret = C.lib3mf_meshobject_gettriangleindices(inst.ref, neededforindices, nil, (*C.sLib3MFTriangle)(unsafe.Pointer(&indices[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return indices[:int(neededforindices)], nil
}

// SetObjectLevelProperty sets the property at the object-level of the mesh object.
func (inst MeshObject) SetObjectLevelProperty(resourceID uint32, propertyID uint32) error {
	ret := C.lib3mf_meshobject_setobjectlevelproperty(inst.ref, C.uint32_t(resourceID), C.uint32_t(propertyID))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetObjectLevelProperty gets the property at the object-level of the mesh object.
func (inst MeshObject) GetObjectLevelProperty() (uint32, uint32, bool, error) {
	var resourceID C.uint32_t
	var propertyID C.uint32_t
	var hasObjectLevelProperty C.bool
	ret := C.lib3mf_meshobject_getobjectlevelproperty(inst.ref, &resourceID, &propertyID, &hasObjectLevelProperty)
	if ret != 0 {
		return 0, 0, false, makeError(uint32(ret))
	}
	return uint32(resourceID), uint32(propertyID), bool(hasObjectLevelProperty), nil
}

// SetTriangleProperties sets the properties of a single triangle of a mesh object.
func (inst MeshObject) SetTriangleProperties(index uint32, properties TriangleProperties) error {
	ret := C.lib3mf_meshobject_settriangleproperties(inst.ref, C.uint32_t(index), (*C.sLib3MFTriangleProperties)(unsafe.Pointer(&properties)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetTriangleProperties gets the properties of a single triangle of a mesh object.
func (inst MeshObject) GetTriangleProperties(index uint32) (TriangleProperties, error) {
	var property C.sLib3MFTriangleProperties
	ret := C.lib3mf_meshobject_gettriangleproperties(inst.ref, C.uint32_t(index), &property)
	if ret != 0 {
		return TriangleProperties{}, makeError(uint32(ret))
	}
	return *(*TriangleProperties)(unsafe.Pointer(&property)), nil
}

// SetAllTriangleProperties sets the properties of all triangles of a mesh object. Sets the object level property to the first entry of the passed triangle properties, if not yet specified.
func (inst MeshObject) SetAllTriangleProperties(propertiesArray []TriangleProperties) error {
	ret := C.lib3mf_meshobject_setalltriangleproperties(inst.ref, C.uint64_t(len(propertiesArray)), (*C.sLib3MFTriangleProperties)(unsafe.Pointer(&propertiesArray[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetAllTriangleProperties gets the properties of all triangles of a mesh object.
func (inst MeshObject) GetAllTriangleProperties(propertiesArray []TriangleProperties) ([]TriangleProperties, error) {
	var neededforpropertiesArray C.uint64_t
	ret := C.lib3mf_meshobject_getalltriangleproperties(inst.ref, 0, &neededforpropertiesArray, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(propertiesArray) < int(neededforpropertiesArray) {
		propertiesArray = append(propertiesArray, make([]TriangleProperties, int(neededforpropertiesArray)-len(propertiesArray))...)
	}
	ret = C.lib3mf_meshobject_getalltriangleproperties(inst.ref, neededforpropertiesArray, nil, (*C.sLib3MFTriangleProperties)(unsafe.Pointer(&propertiesArray[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return propertiesArray[:int(neededforpropertiesArray)], nil
}

// ClearAllProperties clears all properties of this mesh object (triangle and object-level).
func (inst MeshObject) ClearAllProperties() error {
	ret := C.lib3mf_meshobject_clearallproperties(inst.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// SetGeometry set all triangles of a mesh object.
func (inst MeshObject) SetGeometry(vertices []Position, indices []Triangle) error {
	ret := C.lib3mf_meshobject_setgeometry(inst.ref, C.uint64_t(len(vertices)), (*C.sLib3MFPosition)(unsafe.Pointer(&vertices[0])), C.uint64_t(len(indices)), (*C.sLib3MFTriangle)(unsafe.Pointer(&indices[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// IsManifoldAndOriented retrieves, if an object describes a topologically oriented and manifold mesh, according to the core spec.
func (inst MeshObject) IsManifoldAndOriented() (bool, error) {
	var isManifoldAndOriented C.bool
	ret := C.lib3mf_meshobject_ismanifoldandoriented(inst.ref, &isManifoldAndOriented)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(isManifoldAndOriented), nil
}

// BeamLattice retrieves the BeamLattice within this MeshObject.
func (inst MeshObject) BeamLattice() (BeamLattice, error) {
	var theBeamLattice ref
	ret := C.lib3mf_meshobject_beamlattice(inst.ref, &theBeamLattice)
	if ret != 0 {
		return BeamLattice{}, makeError(uint32(ret))
	}
	return newBeamLattice(theBeamLattice), nil
}

// BeamLattice represents a Lib3MF class.
type BeamLattice struct {
	Base
}

func newBeamLattice(r ref) BeamLattice {
	return BeamLattice{NewBase(r)}
}

// GetMinLength returns the minimal length of beams for the beamlattice.
func (inst BeamLattice) GetMinLength() (float64, error) {
	var minLength C.double
	ret := C.lib3mf_beamlattice_getminlength(inst.ref, &minLength)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return float64(minLength), nil
}

// SetMinLength sets the minimal length of beams for the beamlattice.
func (inst BeamLattice) SetMinLength(minLength float64) error {
	ret := C.lib3mf_beamlattice_setminlength(inst.ref, C.double(minLength))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetClipping returns the clipping mode and the clipping-mesh for the beamlattice of this mesh.
func (inst BeamLattice) GetClipping() (BeamLatticeClipMode, uint32, error) {
	var clipMode C.eLib3MFBeamLatticeClipMode
	var resourceID C.uint32_t
	ret := C.lib3mf_beamlattice_getclipping(inst.ref, &clipMode, &resourceID)
	if ret != 0 {
		return 0, 0, makeError(uint32(ret))
	}
	return BeamLatticeClipMode(clipMode), uint32(resourceID), nil
}

// SetClipping sets the clipping mode and the clipping-mesh for the beamlattice of this mesh.
func (inst BeamLattice) SetClipping(clipMode BeamLatticeClipMode, resourceID uint32) error {
	ret := C.lib3mf_beamlattice_setclipping(inst.ref, C.eLib3MFBeamLatticeClipMode(clipMode), C.uint32_t(resourceID))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetRepresentation returns the representation-mesh for the beamlattice of this mesh.
func (inst BeamLattice) GetRepresentation() (bool, uint32, error) {
	var hasRepresentation C.bool
	var resourceID C.uint32_t
	ret := C.lib3mf_beamlattice_getrepresentation(inst.ref, &hasRepresentation, &resourceID)
	if ret != 0 {
		return false, 0, makeError(uint32(ret))
	}
	return bool(hasRepresentation), uint32(resourceID), nil
}

// SetRepresentation sets the representation-mesh for the beamlattice of this mesh.
func (inst BeamLattice) SetRepresentation(resourceID uint32) error {
	ret := C.lib3mf_beamlattice_setrepresentation(inst.ref, C.uint32_t(resourceID))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetBeamCount returns the beam count of a mesh object.
func (inst BeamLattice) GetBeamCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_beamlattice_getbeamcount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// GetBeam returns indices, radii and capmodes of a single beam of a mesh object.
func (inst BeamLattice) GetBeam(index uint32) (Beam, error) {
	var beamInfo C.sLib3MFBeam
	ret := C.lib3mf_beamlattice_getbeam(inst.ref, C.uint32_t(index), &beamInfo)
	if ret != 0 {
		return Beam{}, makeError(uint32(ret))
	}
	return *(*Beam)(unsafe.Pointer(&beamInfo)), nil
}

// AddBeam adds a single beam to a mesh object.
func (inst BeamLattice) AddBeam(beamInfo Beam) (uint32, error) {
	var index C.uint32_t
	ret := C.lib3mf_beamlattice_addbeam(inst.ref, (*C.sLib3MFBeam)(unsafe.Pointer(&beamInfo)), &index)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(index), nil
}

// SetBeam sets the indices, radii and capmodes of a single beam of a mesh object.
func (inst BeamLattice) SetBeam(index uint32, beamInfo Beam) error {
	ret := C.lib3mf_beamlattice_setbeam(inst.ref, C.uint32_t(index), (*C.sLib3MFBeam)(unsafe.Pointer(&beamInfo)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// SetBeams sets all beam indices, radii and capmodes of a mesh object.
func (inst BeamLattice) SetBeams(beamInfo []Beam) error {
	ret := C.lib3mf_beamlattice_setbeams(inst.ref, C.uint64_t(len(beamInfo)), (*C.sLib3MFBeam)(unsafe.Pointer(&beamInfo[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetBeams obtains all beam indices, radii and capmodes of a mesh object.
func (inst BeamLattice) GetBeams(beamInfo []Beam) ([]Beam, error) {
	var neededforbeamInfo C.uint64_t
	ret := C.lib3mf_beamlattice_getbeams(inst.ref, 0, &neededforbeamInfo, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(beamInfo) < int(neededforbeamInfo) {
		beamInfo = append(beamInfo, make([]Beam, int(neededforbeamInfo)-len(beamInfo))...)
	}
	ret = C.lib3mf_beamlattice_getbeams(inst.ref, neededforbeamInfo, nil, (*C.sLib3MFBeam)(unsafe.Pointer(&beamInfo[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return beamInfo[:int(neededforbeamInfo)], nil
}

// GetBeamSetCount returns the number of beamsets of a mesh object.
func (inst BeamLattice) GetBeamSetCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_beamlattice_getbeamsetcount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// AddBeamSet adds an empty beamset to a mesh object.
func (inst BeamLattice) AddBeamSet() (BeamSet, error) {
	var beamSet ref
	ret := C.lib3mf_beamlattice_addbeamset(inst.ref, &beamSet)
	if ret != 0 {
		return BeamSet{}, makeError(uint32(ret))
	}
	return newBeamSet(beamSet), nil
}

// GetBeamSet returns a beamset of a mesh object.
func (inst BeamLattice) GetBeamSet(index uint32) (BeamSet, error) {
	var beamSet ref
	ret := C.lib3mf_beamlattice_getbeamset(inst.ref, C.uint32_t(index), &beamSet)
	if ret != 0 {
		return BeamSet{}, makeError(uint32(ret))
	}
	return newBeamSet(beamSet), nil
}

// Component represents a Lib3MF class.
type Component struct {
	Base
}

func newComponent(r ref) Component {
	return Component{NewBase(r)}
}

// GetObjectResource returns the Resource Instance of the component..
func (inst Component) GetObjectResource() (Object, error) {
	var objectResource ref
	ret := C.lib3mf_component_getobjectresource(inst.ref, &objectResource)
	if ret != 0 {
		return Object{}, makeError(uint32(ret))
	}
	return newObject(objectResource), nil
}

// GetObjectResourceID returns the Resource ID of the component.
func (inst Component) GetObjectResourceID() (uint32, error) {
	var objectResourceID C.uint32_t
	ret := C.lib3mf_component_getobjectresourceid(inst.ref, &objectResourceID)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(objectResourceID), nil
}

// GetUUID returns, whether a component has a UUID and, if true, the component's UUID.
func (inst Component) GetUUID() (bool, string, error) {
	var hasUUID C.bool
	var neededforuUID C.uint32_t
	var filledinuUID C.uint32_t
	ret := C.lib3mf_component_getuuid(inst.ref, &hasUUID, 0, &neededforuUID, nil)
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	bufferSizeuUID := neededforuUID
	bufferuUID := make([]byte, bufferSizeuUID)
	ret = C.lib3mf_component_getuuid(inst.ref, &hasUUID, bufferSizeuUID, &filledinuUID, (*C.char)(unsafe.Pointer(&bufferuUID[0])))
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	return bool(hasUUID), string(bufferuUID[:(filledinuUID - 1)]), nil
}

// SetUUID sets the component's UUID.
func (inst Component) SetUUID(uUID string) error {
	ret := C.lib3mf_component_setuuid(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(uUID)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// HasTransform returns, if the component has a different transformation than the identity matrix.
func (inst Component) HasTransform() (bool, error) {
	var hasTransform C.bool
	ret := C.lib3mf_component_hastransform(inst.ref, &hasTransform)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(hasTransform), nil
}

// GetTransform returns the transformation matrix of the component.
func (inst Component) GetTransform() (Transform, error) {
	var transform C.sLib3MFTransform
	ret := C.lib3mf_component_gettransform(inst.ref, &transform)
	if ret != 0 {
		return Transform{}, makeError(uint32(ret))
	}
	return *(*Transform)(unsafe.Pointer(&transform)), nil
}

// SetTransform sets the transformation matrix of the component.
func (inst Component) SetTransform(transform Transform) error {
	ret := C.lib3mf_component_settransform(inst.ref, (*C.sLib3MFTransform)(unsafe.Pointer(&transform)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// ComponentsObject represents a Lib3MF class.
type ComponentsObject struct {
	Object
}

func newComponentsObject(r ref) ComponentsObject {
	return ComponentsObject{newObject(r)}
}

// AddComponent adds a new component to a components object.
func (inst ComponentsObject) AddComponent(objectResource Object, transform Transform) (Component, error) {
	var componentInstance ref
	ret := C.lib3mf_componentsobject_addcomponent(inst.ref, objectResource.ref, (*C.sLib3MFTransform)(unsafe.Pointer(&transform)), &componentInstance)
	if ret != 0 {
		return Component{}, makeError(uint32(ret))
	}
	return newComponent(componentInstance), nil
}

// GetComponent retrieves a component from a component object.
func (inst ComponentsObject) GetComponent(index uint32) (Component, error) {
	var componentInstance ref
	ret := C.lib3mf_componentsobject_getcomponent(inst.ref, C.uint32_t(index), &componentInstance)
	if ret != 0 {
		return Component{}, makeError(uint32(ret))
	}
	return newComponent(componentInstance), nil
}

// GetComponentCount retrieves a component count of a component object.
func (inst ComponentsObject) GetComponentCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_componentsobject_getcomponentcount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// BeamSet represents a Lib3MF class.
type BeamSet struct {
	Base
}

func newBeamSet(r ref) BeamSet {
	return BeamSet{NewBase(r)}
}

// SetName sets a beamset's name string.
func (inst BeamSet) SetName(name string) error {
	ret := C.lib3mf_beamset_setname(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(name)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetName retrieves a beamset's name string.
func (inst BeamSet) GetName() (string, error) {
	var neededforname C.uint32_t
	var filledinname C.uint32_t
	ret := C.lib3mf_beamset_getname(inst.ref, 0, &neededforname, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizename := neededforname
	buffername := make([]byte, bufferSizename)
	ret = C.lib3mf_beamset_getname(inst.ref, bufferSizename, &filledinname, (*C.char)(unsafe.Pointer(&buffername[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffername[:(filledinname - 1)]), nil
}

// SetIdentifier sets a beamset's identifier string.
func (inst BeamSet) SetIdentifier(identifier string) error {
	ret := C.lib3mf_beamset_setidentifier(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(identifier)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetIdentifier retrieves a beamset's identifier string.
func (inst BeamSet) GetIdentifier() (string, error) {
	var neededforidentifier C.uint32_t
	var filledinidentifier C.uint32_t
	ret := C.lib3mf_beamset_getidentifier(inst.ref, 0, &neededforidentifier, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizeidentifier := neededforidentifier
	bufferidentifier := make([]byte, bufferSizeidentifier)
	ret = C.lib3mf_beamset_getidentifier(inst.ref, bufferSizeidentifier, &filledinidentifier, (*C.char)(unsafe.Pointer(&bufferidentifier[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferidentifier[:(filledinidentifier - 1)]), nil
}

// GetReferenceCount retrieves the reference count of a beamset.
func (inst BeamSet) GetReferenceCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_beamset_getreferencecount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// SetReferences sets the references of a beamset.
func (inst BeamSet) SetReferences(references []uint32) error {
	ret := C.lib3mf_beamset_setreferences(inst.ref, C.uint64_t(len(references)), (*C.uint32_t)(unsafe.Pointer(&references[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetReferences retrieves the references of a beamset.
func (inst BeamSet) GetReferences(references []uint32) ([]uint32, error) {
	var neededforreferences C.uint64_t
	ret := C.lib3mf_beamset_getreferences(inst.ref, 0, &neededforreferences, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(references) < int(neededforreferences) {
		references = append(references, make([]uint32, int(neededforreferences)-len(references))...)
	}
	ret = C.lib3mf_beamset_getreferences(inst.ref, neededforreferences, nil, (*C.uint32_t)(unsafe.Pointer(&references[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return references[:int(neededforreferences)], nil
}

// BaseMaterialGroup represents a Lib3MF class.
type BaseMaterialGroup struct {
	Resource
}

func newBaseMaterialGroup(r ref) BaseMaterialGroup {
	return BaseMaterialGroup{newResource(r)}
}

// GetCount retrieves the count of base materials in the material group.
func (inst BaseMaterialGroup) GetCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_basematerialgroup_getcount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// GetAllPropertyIDs returns all the PropertyIDs of all materials in this group.
func (inst BaseMaterialGroup) GetAllPropertyIDs(propertyIDs []uint32) ([]uint32, error) {
	var neededforpropertyIDs C.uint64_t
	ret := C.lib3mf_basematerialgroup_getallpropertyids(inst.ref, 0, &neededforpropertyIDs, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(propertyIDs) < int(neededforpropertyIDs) {
		propertyIDs = append(propertyIDs, make([]uint32, int(neededforpropertyIDs)-len(propertyIDs))...)
	}
	ret = C.lib3mf_basematerialgroup_getallpropertyids(inst.ref, neededforpropertyIDs, nil, (*C.uint32_t)(unsafe.Pointer(&propertyIDs[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return propertyIDs[:int(neededforpropertyIDs)], nil
}

// AddMaterial adds a new material to the material group.
func (inst BaseMaterialGroup) AddMaterial(name string, displayColor Color) (uint32, error) {
	var propertyID C.uint32_t
	ret := C.lib3mf_basematerialgroup_addmaterial(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(name)[0])), (*C.sLib3MFColor)(unsafe.Pointer(&displayColor)), &propertyID)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(propertyID), nil
}

// RemoveMaterial removes a material from the material group.
func (inst BaseMaterialGroup) RemoveMaterial(propertyID uint32) error {
	ret := C.lib3mf_basematerialgroup_removematerial(inst.ref, C.uint32_t(propertyID))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetName returns the base material's name.
func (inst BaseMaterialGroup) GetName(propertyID uint32) (string, error) {
	var neededforname C.uint32_t
	var filledinname C.uint32_t
	ret := C.lib3mf_basematerialgroup_getname(inst.ref, C.uint32_t(propertyID), 0, &neededforname, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizename := neededforname
	buffername := make([]byte, bufferSizename)
	ret = C.lib3mf_basematerialgroup_getname(inst.ref, C.uint32_t(propertyID), bufferSizename, &filledinname, (*C.char)(unsafe.Pointer(&buffername[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffername[:(filledinname - 1)]), nil
}

// SetName sets a base material's name.
func (inst BaseMaterialGroup) SetName(propertyID uint32, name string) error {
	ret := C.lib3mf_basematerialgroup_setname(inst.ref, C.uint32_t(propertyID), (*C.char)(unsafe.Pointer(&[]byte(name)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// SetDisplayColor sets a base material's display color.
func (inst BaseMaterialGroup) SetDisplayColor(propertyID uint32, theColor Color) error {
	ret := C.lib3mf_basematerialgroup_setdisplaycolor(inst.ref, C.uint32_t(propertyID), (*C.sLib3MFColor)(unsafe.Pointer(&theColor)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetDisplayColor returns a base material's display color.
func (inst BaseMaterialGroup) GetDisplayColor(propertyID uint32) (Color, error) {
	var theColor C.sLib3MFColor
	ret := C.lib3mf_basematerialgroup_getdisplaycolor(inst.ref, C.uint32_t(propertyID), &theColor)
	if ret != 0 {
		return Color{}, makeError(uint32(ret))
	}
	return *(*Color)(unsafe.Pointer(&theColor)), nil
}

// ColorGroup represents a Lib3MF class.
type ColorGroup struct {
	Resource
}

func newColorGroup(r ref) ColorGroup {
	return ColorGroup{newResource(r)}
}

// GetCount retrieves the count of base materials in this Color Group.
func (inst ColorGroup) GetCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_colorgroup_getcount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// GetAllPropertyIDs returns all the PropertyIDs of all colors within this group.
func (inst ColorGroup) GetAllPropertyIDs(propertyIDs []uint32) ([]uint32, error) {
	var neededforpropertyIDs C.uint64_t
	ret := C.lib3mf_colorgroup_getallpropertyids(inst.ref, 0, &neededforpropertyIDs, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(propertyIDs) < int(neededforpropertyIDs) {
		propertyIDs = append(propertyIDs, make([]uint32, int(neededforpropertyIDs)-len(propertyIDs))...)
	}
	ret = C.lib3mf_colorgroup_getallpropertyids(inst.ref, neededforpropertyIDs, nil, (*C.uint32_t)(unsafe.Pointer(&propertyIDs[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return propertyIDs[:int(neededforpropertyIDs)], nil
}

// AddColor adds a new value.
func (inst ColorGroup) AddColor(theColor Color) (uint32, error) {
	var propertyID C.uint32_t
	ret := C.lib3mf_colorgroup_addcolor(inst.ref, (*C.sLib3MFColor)(unsafe.Pointer(&theColor)), &propertyID)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(propertyID), nil
}

// RemoveColor removes a color from the color group.
func (inst ColorGroup) RemoveColor(propertyID uint32) error {
	ret := C.lib3mf_colorgroup_removecolor(inst.ref, C.uint32_t(propertyID))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// SetColor sets a color value.
func (inst ColorGroup) SetColor(propertyID uint32, theColor Color) error {
	ret := C.lib3mf_colorgroup_setcolor(inst.ref, C.uint32_t(propertyID), (*C.sLib3MFColor)(unsafe.Pointer(&theColor)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetColor sets a color value.
func (inst ColorGroup) GetColor(propertyID uint32) (Color, error) {
	var theColor C.sLib3MFColor
	ret := C.lib3mf_colorgroup_getcolor(inst.ref, C.uint32_t(propertyID), &theColor)
	if ret != 0 {
		return Color{}, makeError(uint32(ret))
	}
	return *(*Color)(unsafe.Pointer(&theColor)), nil
}

// Texture2DGroup represents a Lib3MF class.
type Texture2DGroup struct {
	Resource
}

func newTexture2DGroup(r ref) Texture2DGroup {
	return Texture2DGroup{newResource(r)}
}

// GetCount retrieves the count of tex2coords in the Texture2DGroup.
func (inst Texture2DGroup) GetCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_texture2dgroup_getcount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// GetAllPropertyIDs returns all the PropertyIDs of all tex2coords in this Texture2DGroup.
func (inst Texture2DGroup) GetAllPropertyIDs(propertyIDs []uint32) ([]uint32, error) {
	var neededforpropertyIDs C.uint64_t
	ret := C.lib3mf_texture2dgroup_getallpropertyids(inst.ref, 0, &neededforpropertyIDs, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(propertyIDs) < int(neededforpropertyIDs) {
		propertyIDs = append(propertyIDs, make([]uint32, int(neededforpropertyIDs)-len(propertyIDs))...)
	}
	ret = C.lib3mf_texture2dgroup_getallpropertyids(inst.ref, neededforpropertyIDs, nil, (*C.uint32_t)(unsafe.Pointer(&propertyIDs[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return propertyIDs[:int(neededforpropertyIDs)], nil
}

// AddTex2Coord adds a new tex2coord to the Texture2DGroup.
func (inst Texture2DGroup) AddTex2Coord(uVCoordinate Tex2Coord) (uint32, error) {
	var propertyID C.uint32_t
	ret := C.lib3mf_texture2dgroup_addtex2coord(inst.ref, (*C.sLib3MFTex2Coord)(unsafe.Pointer(&uVCoordinate)), &propertyID)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(propertyID), nil
}

// GetTex2Coord obtains a tex2coord to the Texture2DGroup.
func (inst Texture2DGroup) GetTex2Coord(propertyID uint32) (Tex2Coord, error) {
	var uVCoordinate C.sLib3MFTex2Coord
	ret := C.lib3mf_texture2dgroup_gettex2coord(inst.ref, C.uint32_t(propertyID), &uVCoordinate)
	if ret != 0 {
		return Tex2Coord{}, makeError(uint32(ret))
	}
	return *(*Tex2Coord)(unsafe.Pointer(&uVCoordinate)), nil
}

// RemoveTex2Coord removes a tex2coords from the Texture2DGroup.
func (inst Texture2DGroup) RemoveTex2Coord(propertyID uint32) error {
	ret := C.lib3mf_texture2dgroup_removetex2coord(inst.ref, C.uint32_t(propertyID))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetTexture2D obtains the texture2D instance of this group.
func (inst Texture2DGroup) GetTexture2D() (Texture2D, error) {
	var texture2DInstance ref
	ret := C.lib3mf_texture2dgroup_gettexture2d(inst.ref, &texture2DInstance)
	if ret != 0 {
		return Texture2D{}, makeError(uint32(ret))
	}
	return newTexture2D(texture2DInstance), nil
}

// CompositeMaterials represents a Lib3MF class.
type CompositeMaterials struct {
	Resource
}

func newCompositeMaterials(r ref) CompositeMaterials {
	return CompositeMaterials{newResource(r)}
}

// GetCount retrieves the count of Composite-s in the CompositeMaterials.
func (inst CompositeMaterials) GetCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_compositematerials_getcount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// GetAllPropertyIDs returns all the PropertyIDs of all Composite-Mixing Values in this CompositeMaterials.
func (inst CompositeMaterials) GetAllPropertyIDs(propertyIDs []uint32) ([]uint32, error) {
	var neededforpropertyIDs C.uint64_t
	ret := C.lib3mf_compositematerials_getallpropertyids(inst.ref, 0, &neededforpropertyIDs, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(propertyIDs) < int(neededforpropertyIDs) {
		propertyIDs = append(propertyIDs, make([]uint32, int(neededforpropertyIDs)-len(propertyIDs))...)
	}
	ret = C.lib3mf_compositematerials_getallpropertyids(inst.ref, neededforpropertyIDs, nil, (*C.uint32_t)(unsafe.Pointer(&propertyIDs[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return propertyIDs[:int(neededforpropertyIDs)], nil
}

// GetBaseMaterialGroup obtains the BaseMaterialGroup instance of this CompositeMaterials.
func (inst CompositeMaterials) GetBaseMaterialGroup() (BaseMaterialGroup, error) {
	var baseMaterialGroupInstance ref
	ret := C.lib3mf_compositematerials_getbasematerialgroup(inst.ref, &baseMaterialGroupInstance)
	if ret != 0 {
		return BaseMaterialGroup{}, makeError(uint32(ret))
	}
	return newBaseMaterialGroup(baseMaterialGroupInstance), nil
}

// AddComposite adds a new Composite-Mixing Values to the CompositeMaterials.
func (inst CompositeMaterials) AddComposite(composite []CompositeConstituent) (uint32, error) {
	var propertyID C.uint32_t
	ret := C.lib3mf_compositematerials_addcomposite(inst.ref, C.uint64_t(len(composite)), (*C.sLib3MFCompositeConstituent)(unsafe.Pointer(&composite[0])), &propertyID)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(propertyID), nil
}

// RemoveComposite removes a Composite-Maxing Ratio from the CompositeMaterials.
func (inst CompositeMaterials) RemoveComposite(propertyID uint32) error {
	ret := C.lib3mf_compositematerials_removecomposite(inst.ref, C.uint32_t(propertyID))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetComposite obtains a Composite-Maxing Ratio of this CompositeMaterials.
func (inst CompositeMaterials) GetComposite(propertyID uint32, composite []CompositeConstituent) ([]CompositeConstituent, error) {
	var neededforcomposite C.uint64_t
	ret := C.lib3mf_compositematerials_getcomposite(inst.ref, C.uint32_t(propertyID), 0, &neededforcomposite, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(composite) < int(neededforcomposite) {
		composite = append(composite, make([]CompositeConstituent, int(neededforcomposite)-len(composite))...)
	}
	ret = C.lib3mf_compositematerials_getcomposite(inst.ref, C.uint32_t(propertyID), neededforcomposite, nil, (*C.sLib3MFCompositeConstituent)(unsafe.Pointer(&composite[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return composite[:int(neededforcomposite)], nil
}

// MultiPropertyGroup represents a Lib3MF class.
type MultiPropertyGroup struct {
	Resource
}

func newMultiPropertyGroup(r ref) MultiPropertyGroup {
	return MultiPropertyGroup{newResource(r)}
}

// GetCount retrieves the count of MultiProperty-s in the MultiPropertyGroup.
func (inst MultiPropertyGroup) GetCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_multipropertygroup_getcount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// GetAllPropertyIDs returns all the PropertyIDs of all MultiProperty-s in this MultiPropertyGroup.
func (inst MultiPropertyGroup) GetAllPropertyIDs(propertyIDs []uint32) ([]uint32, error) {
	var neededforpropertyIDs C.uint64_t
	ret := C.lib3mf_multipropertygroup_getallpropertyids(inst.ref, 0, &neededforpropertyIDs, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(propertyIDs) < int(neededforpropertyIDs) {
		propertyIDs = append(propertyIDs, make([]uint32, int(neededforpropertyIDs)-len(propertyIDs))...)
	}
	ret = C.lib3mf_multipropertygroup_getallpropertyids(inst.ref, neededforpropertyIDs, nil, (*C.uint32_t)(unsafe.Pointer(&propertyIDs[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return propertyIDs[:int(neededforpropertyIDs)], nil
}

// AddMultiProperty adds a new MultiProperty to the MultiPropertyGroup.
func (inst MultiPropertyGroup) AddMultiProperty(propertyIDs []uint32) (uint32, error) {
	var propertyID C.uint32_t
	ret := C.lib3mf_multipropertygroup_addmultiproperty(inst.ref, C.uint64_t(len(propertyIDs)), (*C.uint32_t)(unsafe.Pointer(&propertyIDs[0])), &propertyID)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(propertyID), nil
}

// SetMultiProperty sets the PropertyIDs of a MultiProperty.
func (inst MultiPropertyGroup) SetMultiProperty(propertyID uint32, propertyIDs []uint32) error {
	ret := C.lib3mf_multipropertygroup_setmultiproperty(inst.ref, C.uint32_t(propertyID), C.uint64_t(len(propertyIDs)), (*C.uint32_t)(unsafe.Pointer(&propertyIDs[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetMultiProperty obtains the PropertyIDs of a MultiProperty.
func (inst MultiPropertyGroup) GetMultiProperty(propertyID uint32, propertyIDs []uint32) ([]uint32, error) {
	var neededforpropertyIDs C.uint64_t
	ret := C.lib3mf_multipropertygroup_getmultiproperty(inst.ref, C.uint32_t(propertyID), 0, &neededforpropertyIDs, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(propertyIDs) < int(neededforpropertyIDs) {
		propertyIDs = append(propertyIDs, make([]uint32, int(neededforpropertyIDs)-len(propertyIDs))...)
	}
	ret = C.lib3mf_multipropertygroup_getmultiproperty(inst.ref, C.uint32_t(propertyID), neededforpropertyIDs, nil, (*C.uint32_t)(unsafe.Pointer(&propertyIDs[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return propertyIDs[:int(neededforpropertyIDs)], nil
}

// RemoveMultiProperty removes a MultiProperty from this MultiPropertyGroup.
func (inst MultiPropertyGroup) RemoveMultiProperty(propertyID uint32) error {
	ret := C.lib3mf_multipropertygroup_removemultiproperty(inst.ref, C.uint32_t(propertyID))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetLayerCount retrieves the number of layers of this MultiPropertyGroup.
func (inst MultiPropertyGroup) GetLayerCount() (uint32, error) {
	var count C.uint32_t
	ret := C.lib3mf_multipropertygroup_getlayercount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(count), nil
}

// AddLayer adds a MultiPropertyLayer to this MultiPropertyGroup.
func (inst MultiPropertyGroup) AddLayer(theLayer MultiPropertyLayer) (uint32, error) {
	var layerIndex C.uint32_t
	ret := C.lib3mf_multipropertygroup_addlayer(inst.ref, (*C.sLib3MFMultiPropertyLayer)(unsafe.Pointer(&theLayer)), &layerIndex)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(layerIndex), nil
}

// GetLayer obtains a MultiPropertyLayer of this MultiPropertyGroup.
func (inst MultiPropertyGroup) GetLayer(layerIndex uint32) (MultiPropertyLayer, error) {
	var theLayer C.sLib3MFMultiPropertyLayer
	ret := C.lib3mf_multipropertygroup_getlayer(inst.ref, C.uint32_t(layerIndex), &theLayer)
	if ret != 0 {
		return MultiPropertyLayer{}, makeError(uint32(ret))
	}
	return *(*MultiPropertyLayer)(unsafe.Pointer(&theLayer)), nil
}

// RemoveLayer removes a MultiPropertyLayer from this MultiPropertyGroup.
func (inst MultiPropertyGroup) RemoveLayer(layerIndex uint32) error {
	ret := C.lib3mf_multipropertygroup_removelayer(inst.ref, C.uint32_t(layerIndex))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// Attachment represents a Lib3MF class.
type Attachment struct {
	Base
}

func newAttachment(r ref) Attachment {
	return Attachment{NewBase(r)}
}

// GetPath retrieves an attachment's package path.
func (inst Attachment) GetPath() (string, error) {
	var neededforpath C.uint32_t
	var filledinpath C.uint32_t
	ret := C.lib3mf_attachment_getpath(inst.ref, 0, &neededforpath, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizepath := neededforpath
	bufferpath := make([]byte, bufferSizepath)
	ret = C.lib3mf_attachment_getpath(inst.ref, bufferSizepath, &filledinpath, (*C.char)(unsafe.Pointer(&bufferpath[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferpath[:(filledinpath - 1)]), nil
}

// SetPath sets an attachment's package path.
func (inst Attachment) SetPath(path string) error {
	ret := C.lib3mf_attachment_setpath(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(path)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetRelationShipType retrieves an attachment's relationship type.
func (inst Attachment) GetRelationShipType() (string, error) {
	var neededforpath C.uint32_t
	var filledinpath C.uint32_t
	ret := C.lib3mf_attachment_getrelationshiptype(inst.ref, 0, &neededforpath, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizepath := neededforpath
	bufferpath := make([]byte, bufferSizepath)
	ret = C.lib3mf_attachment_getrelationshiptype(inst.ref, bufferSizepath, &filledinpath, (*C.char)(unsafe.Pointer(&bufferpath[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferpath[:(filledinpath - 1)]), nil
}

// SetRelationShipType sets an attachment's relationship type.
func (inst Attachment) SetRelationShipType(path string) error {
	ret := C.lib3mf_attachment_setrelationshiptype(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(path)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// WriteToFile writes out the attachment as file.
func (inst Attachment) WriteToFile(fileName string) error {
	ret := C.lib3mf_attachment_writetofile(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(fileName)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// ReadFromFile reads an attachment from a file.
func (inst Attachment) ReadFromFile(fileName string) error {
	ret := C.lib3mf_attachment_readfromfile(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(fileName)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetStreamSize retrieves the size of the attachment stream.
func (inst Attachment) GetStreamSize() (uint64, error) {
	var streamSize C.uint64_t
	ret := C.lib3mf_attachment_getstreamsize(inst.ref, &streamSize)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(streamSize), nil
}

// WriteToBuffer writes out the attachment into a buffer.
func (inst Attachment) WriteToBuffer(buffer []uint8) ([]uint8, error) {
	var neededforbuffer C.uint64_t
	ret := C.lib3mf_attachment_writetobuffer(inst.ref, 0, &neededforbuffer, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(buffer) < int(neededforbuffer) {
		buffer = append(buffer, make([]uint8, int(neededforbuffer)-len(buffer))...)
	}
	ret = C.lib3mf_attachment_writetobuffer(inst.ref, neededforbuffer, nil, (*C.uint8_t)(unsafe.Pointer(&buffer[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return buffer[:int(neededforbuffer)], nil
}

// ReadFromBuffer reads an attachment from a memory buffer.
func (inst Attachment) ReadFromBuffer(buffer []uint8) error {
	ret := C.lib3mf_attachment_readfrombuffer(inst.ref, C.uint64_t(len(buffer)), (*C.uint8_t)(unsafe.Pointer(&buffer[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// Texture2D represents a Lib3MF class.
type Texture2D struct {
	Resource
}

func newTexture2D(r ref) Texture2D {
	return Texture2D{newResource(r)}
}

// GetAttachment retrieves the attachment located at the path of the texture.
func (inst Texture2D) GetAttachment() (Attachment, error) {
	var attachment ref
	ret := C.lib3mf_texture2d_getattachment(inst.ref, &attachment)
	if ret != 0 {
		return Attachment{}, makeError(uint32(ret))
	}
	return newAttachment(attachment), nil
}

// SetAttachment sets the texture's package path to the path of the attachment.
func (inst Texture2D) SetAttachment(attachment Attachment) error {
	ret := C.lib3mf_texture2d_setattachment(inst.ref, attachment.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetContentType retrieves a texture's content type.
func (inst Texture2D) GetContentType() (TextureType, error) {
	var contentType C.eLib3MFTextureType
	ret := C.lib3mf_texture2d_getcontenttype(inst.ref, &contentType)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return TextureType(contentType), nil
}

// SetContentType retrieves a texture's content type.
func (inst Texture2D) SetContentType(contentType TextureType) error {
	ret := C.lib3mf_texture2d_setcontenttype(inst.ref, C.eLib3MFTextureType(contentType))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetTileStyleUV retrieves a texture's tilestyle type.
func (inst Texture2D) GetTileStyleUV() (TextureTileStyle, TextureTileStyle, error) {
	var tileStyleU C.eLib3MFTextureTileStyle
	var tileStyleV C.eLib3MFTextureTileStyle
	ret := C.lib3mf_texture2d_gettilestyleuv(inst.ref, &tileStyleU, &tileStyleV)
	if ret != 0 {
		return 0, 0, makeError(uint32(ret))
	}
	return TextureTileStyle(tileStyleU), TextureTileStyle(tileStyleV), nil
}

// SetTileStyleUV sets a texture's tilestyle type.
func (inst Texture2D) SetTileStyleUV(tileStyleU TextureTileStyle, tileStyleV TextureTileStyle) error {
	ret := C.lib3mf_texture2d_settilestyleuv(inst.ref, C.eLib3MFTextureTileStyle(tileStyleU), C.eLib3MFTextureTileStyle(tileStyleV))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetFilter retrieves a texture's filter type.
func (inst Texture2D) GetFilter() (TextureFilter, error) {
	var filter C.eLib3MFTextureFilter
	ret := C.lib3mf_texture2d_getfilter(inst.ref, &filter)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return TextureFilter(filter), nil
}

// SetFilter sets a texture's filter type.
func (inst Texture2D) SetFilter(filter TextureFilter) error {
	ret := C.lib3mf_texture2d_setfilter(inst.ref, C.eLib3MFTextureFilter(filter))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// BuildItem represents a Lib3MF class.
type BuildItem struct {
	Base
}

func newBuildItem(r ref) BuildItem {
	return BuildItem{NewBase(r)}
}

// GetObjectResource retrieves the object resource associated to a build item.
func (inst BuildItem) GetObjectResource() (Object, error) {
	var objectResource ref
	ret := C.lib3mf_builditem_getobjectresource(inst.ref, &objectResource)
	if ret != 0 {
		return Object{}, makeError(uint32(ret))
	}
	return newObject(objectResource), nil
}

// GetUUID returns, whether a build item has a UUID and, if true, the build item's UUID.
func (inst BuildItem) GetUUID() (bool, string, error) {
	var hasUUID C.bool
	var neededforuUID C.uint32_t
	var filledinuUID C.uint32_t
	ret := C.lib3mf_builditem_getuuid(inst.ref, &hasUUID, 0, &neededforuUID, nil)
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	bufferSizeuUID := neededforuUID
	bufferuUID := make([]byte, bufferSizeuUID)
	ret = C.lib3mf_builditem_getuuid(inst.ref, &hasUUID, bufferSizeuUID, &filledinuUID, (*C.char)(unsafe.Pointer(&bufferuUID[0])))
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	return bool(hasUUID), string(bufferuUID[:(filledinuUID - 1)]), nil
}

// SetUUID sets the build item's UUID.
func (inst BuildItem) SetUUID(uUID string) error {
	ret := C.lib3mf_builditem_setuuid(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(uUID)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetObjectResourceID retrieves the object resource id associated to a build item.
func (inst BuildItem) GetObjectResourceID() (uint32, error) {
	var id C.uint32_t
	ret := C.lib3mf_builditem_getobjectresourceid(inst.ref, &id)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(id), nil
}

// HasObjectTransform checks, if a build item has a non-identity transformation matrix.
func (inst BuildItem) HasObjectTransform() (bool, error) {
	var hasTransform C.bool
	ret := C.lib3mf_builditem_hasobjecttransform(inst.ref, &hasTransform)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(hasTransform), nil
}

// GetObjectTransform retrieves a build item's transformation matrix.
func (inst BuildItem) GetObjectTransform() (Transform, error) {
	var transform C.sLib3MFTransform
	ret := C.lib3mf_builditem_getobjecttransform(inst.ref, &transform)
	if ret != 0 {
		return Transform{}, makeError(uint32(ret))
	}
	return *(*Transform)(unsafe.Pointer(&transform)), nil
}

// SetObjectTransform sets a build item's transformation matrix.
func (inst BuildItem) SetObjectTransform(transform Transform) error {
	ret := C.lib3mf_builditem_setobjecttransform(inst.ref, (*C.sLib3MFTransform)(unsafe.Pointer(&transform)))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetPartNumber retrieves a build item's part number string.
func (inst BuildItem) GetPartNumber() (string, error) {
	var neededforpartNumber C.uint32_t
	var filledinpartNumber C.uint32_t
	ret := C.lib3mf_builditem_getpartnumber(inst.ref, 0, &neededforpartNumber, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizepartNumber := neededforpartNumber
	bufferpartNumber := make([]byte, bufferSizepartNumber)
	ret = C.lib3mf_builditem_getpartnumber(inst.ref, bufferSizepartNumber, &filledinpartNumber, (*C.char)(unsafe.Pointer(&bufferpartNumber[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferpartNumber[:(filledinpartNumber - 1)]), nil
}

// SetPartNumber sets a build item's part number string.
func (inst BuildItem) SetPartNumber(setPartnumber string) error {
	ret := C.lib3mf_builditem_setpartnumber(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(setPartnumber)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetMetaDataGroup returns the metadatagroup of this build item.
func (inst BuildItem) GetMetaDataGroup() (MetaDataGroup, error) {
	var metaDataGroup ref
	ret := C.lib3mf_builditem_getmetadatagroup(inst.ref, &metaDataGroup)
	if ret != 0 {
		return MetaDataGroup{}, makeError(uint32(ret))
	}
	return newMetaDataGroup(metaDataGroup), nil
}

// GetOutbox returns the outbox of a build item.
func (inst BuildItem) GetOutbox() (Box, error) {
	var outbox C.sLib3MFBox
	ret := C.lib3mf_builditem_getoutbox(inst.ref, &outbox)
	if ret != 0 {
		return Box{}, makeError(uint32(ret))
	}
	return *(*Box)(unsafe.Pointer(&outbox)), nil
}

// BuildItemIterator represents a Lib3MF class.
type BuildItemIterator struct {
	Base
}

func newBuildItemIterator(r ref) BuildItemIterator {
	return BuildItemIterator{NewBase(r)}
}

// MoveNext iterates to the next build item in the list.
func (inst BuildItemIterator) MoveNext() (bool, error) {
	var hasNext C.bool
	ret := C.lib3mf_builditemiterator_movenext(inst.ref, &hasNext)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(hasNext), nil
}

// MovePrevious iterates to the previous build item in the list.
func (inst BuildItemIterator) MovePrevious() (bool, error) {
	var hasPrevious C.bool
	ret := C.lib3mf_builditemiterator_moveprevious(inst.ref, &hasPrevious)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(hasPrevious), nil
}

// GetCurrent returns the build item the iterator points at.
func (inst BuildItemIterator) GetCurrent() (BuildItem, error) {
	var buildItem ref
	ret := C.lib3mf_builditemiterator_getcurrent(inst.ref, &buildItem)
	if ret != 0 {
		return BuildItem{}, makeError(uint32(ret))
	}
	return newBuildItem(buildItem), nil
}

// Clone creates a new build item iterator with the same build item list.
func (inst BuildItemIterator) Clone() (BuildItemIterator, error) {
	var outBuildItemIterator ref
	ret := C.lib3mf_builditemiterator_clone(inst.ref, &outBuildItemIterator)
	if ret != 0 {
		return BuildItemIterator{}, makeError(uint32(ret))
	}
	return newBuildItemIterator(outBuildItemIterator), nil
}

// Count returns the number of build items the iterator captures.
func (inst BuildItemIterator) Count() (uint64, error) {
	var count C.uint64_t
	ret := C.lib3mf_builditemiterator_count(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(count), nil
}

// Slice represents a Lib3MF class.
type Slice struct {
	Base
}

func newSlice(r ref) Slice {
	return Slice{NewBase(r)}
}

// SetVertices set all vertices of a slice. All polygons will be cleared.
func (inst Slice) SetVertices(vertices []Position2D) error {
	ret := C.lib3mf_slice_setvertices(inst.ref, C.uint64_t(len(vertices)), (*C.sLib3MFPosition2D)(unsafe.Pointer(&vertices[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetVertices get all vertices of a slice.
func (inst Slice) GetVertices(vertices []Position2D) ([]Position2D, error) {
	var neededforvertices C.uint64_t
	ret := C.lib3mf_slice_getvertices(inst.ref, 0, &neededforvertices, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(vertices) < int(neededforvertices) {
		vertices = append(vertices, make([]Position2D, int(neededforvertices)-len(vertices))...)
	}
	ret = C.lib3mf_slice_getvertices(inst.ref, neededforvertices, nil, (*C.sLib3MFPosition2D)(unsafe.Pointer(&vertices[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return vertices[:int(neededforvertices)], nil
}

// GetVertexCount get the number of vertices in a slice.
func (inst Slice) GetVertexCount() (uint64, error) {
	var count C.uint64_t
	ret := C.lib3mf_slice_getvertexcount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(count), nil
}

// AddPolygon add a new polygon to this slice.
func (inst Slice) AddPolygon(indices []uint32) (uint64, error) {
	var index C.uint64_t
	ret := C.lib3mf_slice_addpolygon(inst.ref, C.uint64_t(len(indices)), (*C.uint32_t)(unsafe.Pointer(&indices[0])), &index)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(index), nil
}

// GetPolygonCount get the number of polygons in the slice.
func (inst Slice) GetPolygonCount() (uint64, error) {
	var count C.uint64_t
	ret := C.lib3mf_slice_getpolygoncount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(count), nil
}

// SetPolygonIndices set all indices of a polygon.
func (inst Slice) SetPolygonIndices(index uint64, indices []uint32) error {
	ret := C.lib3mf_slice_setpolygonindices(inst.ref, C.uint64_t(index), C.uint64_t(len(indices)), (*C.uint32_t)(unsafe.Pointer(&indices[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetPolygonIndices get all vertices of a slice.
func (inst Slice) GetPolygonIndices(index uint64, indices []uint32) ([]uint32, error) {
	var neededforindices C.uint64_t
	ret := C.lib3mf_slice_getpolygonindices(inst.ref, C.uint64_t(index), 0, &neededforindices, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(indices) < int(neededforindices) {
		indices = append(indices, make([]uint32, int(neededforindices)-len(indices))...)
	}
	ret = C.lib3mf_slice_getpolygonindices(inst.ref, C.uint64_t(index), neededforindices, nil, (*C.uint32_t)(unsafe.Pointer(&indices[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return indices[:int(neededforindices)], nil
}

// GetPolygonIndexCount get the number of vertices in a slice.
func (inst Slice) GetPolygonIndexCount(index uint64) (uint64, error) {
	var count C.uint64_t
	ret := C.lib3mf_slice_getpolygonindexcount(inst.ref, C.uint64_t(index), &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(count), nil
}

// GetZTop get the upper Z-Coordinate of this slice.
func (inst Slice) GetZTop() (float64, error) {
	var zTop C.double
	ret := C.lib3mf_slice_getztop(inst.ref, &zTop)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return float64(zTop), nil
}

// SliceStack represents a Lib3MF class.
type SliceStack struct {
	Resource
}

func newSliceStack(r ref) SliceStack {
	return SliceStack{newResource(r)}
}

// GetBottomZ get the lower Z-Coordinate of the slice stack.
func (inst SliceStack) GetBottomZ() (float64, error) {
	var zBottom C.double
	ret := C.lib3mf_slicestack_getbottomz(inst.ref, &zBottom)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return float64(zBottom), nil
}

// GetSliceCount returns the number of slices.
func (inst SliceStack) GetSliceCount() (uint64, error) {
	var count C.uint64_t
	ret := C.lib3mf_slicestack_getslicecount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(count), nil
}

// GetSlice query a slice from the slice stack.
func (inst SliceStack) GetSlice(sliceIndex uint64) (Slice, error) {
	var theSlice ref
	ret := C.lib3mf_slicestack_getslice(inst.ref, C.uint64_t(sliceIndex), &theSlice)
	if ret != 0 {
		return Slice{}, makeError(uint32(ret))
	}
	return newSlice(theSlice), nil
}

// AddSlice returns the number of slices.
func (inst SliceStack) AddSlice(zTop float64) (Slice, error) {
	var theSlice ref
	ret := C.lib3mf_slicestack_addslice(inst.ref, C.double(zTop), &theSlice)
	if ret != 0 {
		return Slice{}, makeError(uint32(ret))
	}
	return newSlice(theSlice), nil
}

// GetSliceRefCount returns the number of slice refs.
func (inst SliceStack) GetSliceRefCount() (uint64, error) {
	var count C.uint64_t
	ret := C.lib3mf_slicestack_getslicerefcount(inst.ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(count), nil
}

// AddSliceStackReference adds another existing slicestack as sliceref in this slicestack.
func (inst SliceStack) AddSliceStackReference(theSliceStack SliceStack) error {
	ret := C.lib3mf_slicestack_addslicestackreference(inst.ref, theSliceStack.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetSliceStackReference adds another existing slicestack as sliceref in this slicestack.
func (inst SliceStack) GetSliceStackReference(sliceRefIndex uint64) (SliceStack, error) {
	var theSliceStack ref
	ret := C.lib3mf_slicestack_getslicestackreference(inst.ref, C.uint64_t(sliceRefIndex), &theSliceStack)
	if ret != 0 {
		return SliceStack{}, makeError(uint32(ret))
	}
	return newSliceStack(theSliceStack), nil
}

// CollapseSliceReferences removes the indirection of slices via slice-refs, i.e. creates the slices of all slice refs of this SliceStack as actual slices of this SliceStack. All previously existing slices or slicerefs will be removed.
func (inst SliceStack) CollapseSliceReferences() error {
	ret := C.lib3mf_slicestack_collapseslicereferences(inst.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// SetOwnPath sets the package path where this Slice should be stored. Input an empty string to reset the path.
func (inst SliceStack) SetOwnPath(path string) error {
	ret := C.lib3mf_slicestack_setownpath(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(path)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetOwnPath obtains the package path where this Slice should be stored. Returns an empty string if the slicestack is stored within the root model.
func (inst SliceStack) GetOwnPath() (string, error) {
	var neededforpath C.uint32_t
	var filledinpath C.uint32_t
	ret := C.lib3mf_slicestack_getownpath(inst.ref, 0, &neededforpath, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizepath := neededforpath
	bufferpath := make([]byte, bufferSizepath)
	ret = C.lib3mf_slicestack_getownpath(inst.ref, bufferSizepath, &filledinpath, (*C.char)(unsafe.Pointer(&bufferpath[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferpath[:(filledinpath - 1)]), nil
}

// Model represents a Lib3MF class.
type Model struct {
	Base
}

func newModel(r ref) Model {
	return Model{NewBase(r)}
}

// SetUnit sets the units of a model.
func (inst Model) SetUnit(unit ModelUnit) error {
	ret := C.lib3mf_model_setunit(inst.ref, C.eLib3MFModelUnit(unit))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetUnit returns the units of a model.
func (inst Model) GetUnit() (ModelUnit, error) {
	var unit C.eLib3MFModelUnit
	ret := C.lib3mf_model_getunit(inst.ref, &unit)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return ModelUnit(unit), nil
}

// GetLanguage retrieves the language of a model.
func (inst Model) GetLanguage() (string, error) {
	var neededforlanguage C.uint32_t
	var filledinlanguage C.uint32_t
	ret := C.lib3mf_model_getlanguage(inst.ref, 0, &neededforlanguage, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizelanguage := neededforlanguage
	bufferlanguage := make([]byte, bufferSizelanguage)
	ret = C.lib3mf_model_getlanguage(inst.ref, bufferSizelanguage, &filledinlanguage, (*C.char)(unsafe.Pointer(&bufferlanguage[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferlanguage[:(filledinlanguage - 1)]), nil
}

// SetLanguage sets the language of a model.
func (inst Model) SetLanguage(language string) error {
	ret := C.lib3mf_model_setlanguage(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(language)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// QueryWriter creates a model writer instance for a specific file type.
func (inst Model) QueryWriter(writerClass string) (Writer, error) {
	var writerInstance ref
	ret := C.lib3mf_model_querywriter(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(writerClass)[0])), &writerInstance)
	if ret != 0 {
		return Writer{}, makeError(uint32(ret))
	}
	return newWriter(writerInstance), nil
}

// QueryReader creates a model reader instance for a specific file type.
func (inst Model) QueryReader(readerClass string) (Reader, error) {
	var readerInstance ref
	ret := C.lib3mf_model_queryreader(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(readerClass)[0])), &readerInstance)
	if ret != 0 {
		return Reader{}, makeError(uint32(ret))
	}
	return newReader(readerInstance), nil
}

// GetTexture2DByID finds a model texture by its id.
func (inst Model) GetTexture2DByID(resourceID uint32) (Texture2D, error) {
	var textureInstance ref
	ret := C.lib3mf_model_gettexture2dbyid(inst.ref, C.uint32_t(resourceID), &textureInstance)
	if ret != 0 {
		return Texture2D{}, makeError(uint32(ret))
	}
	return newTexture2D(textureInstance), nil
}

// GetPropertyTypeByID returns a Property's type.
func (inst Model) GetPropertyTypeByID(resourceID uint32) (PropertyType, error) {
	var thePropertyType C.eLib3MFPropertyType
	ret := C.lib3mf_model_getpropertytypebyid(inst.ref, C.uint32_t(resourceID), &thePropertyType)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return PropertyType(thePropertyType), nil
}

// GetBaseMaterialGroupByID finds a model base material group by its id.
func (inst Model) GetBaseMaterialGroupByID(resourceID uint32) (BaseMaterialGroup, error) {
	var baseMaterialGroupInstance ref
	ret := C.lib3mf_model_getbasematerialgroupbyid(inst.ref, C.uint32_t(resourceID), &baseMaterialGroupInstance)
	if ret != 0 {
		return BaseMaterialGroup{}, makeError(uint32(ret))
	}
	return newBaseMaterialGroup(baseMaterialGroupInstance), nil
}

// GetTexture2DGroupByID finds a model texture2d group by its id.
func (inst Model) GetTexture2DGroupByID(resourceID uint32) (Texture2DGroup, error) {
	var texture2DGroupInstance ref
	ret := C.lib3mf_model_gettexture2dgroupbyid(inst.ref, C.uint32_t(resourceID), &texture2DGroupInstance)
	if ret != 0 {
		return Texture2DGroup{}, makeError(uint32(ret))
	}
	return newTexture2DGroup(texture2DGroupInstance), nil
}

// GetCompositeMaterialsByID finds a model CompositeMaterials by its id.
func (inst Model) GetCompositeMaterialsByID(resourceID uint32) (CompositeMaterials, error) {
	var compositeMaterialsInstance ref
	ret := C.lib3mf_model_getcompositematerialsbyid(inst.ref, C.uint32_t(resourceID), &compositeMaterialsInstance)
	if ret != 0 {
		return CompositeMaterials{}, makeError(uint32(ret))
	}
	return newCompositeMaterials(compositeMaterialsInstance), nil
}

// GetMultiPropertyGroupByID finds a model MultiPropertyGroup by its id.
func (inst Model) GetMultiPropertyGroupByID(resourceID uint32) (MultiPropertyGroup, error) {
	var multiPropertyGroupInstance ref
	ret := C.lib3mf_model_getmultipropertygroupbyid(inst.ref, C.uint32_t(resourceID), &multiPropertyGroupInstance)
	if ret != 0 {
		return MultiPropertyGroup{}, makeError(uint32(ret))
	}
	return newMultiPropertyGroup(multiPropertyGroupInstance), nil
}

// GetMeshObjectByID finds a mesh object by its id.
func (inst Model) GetMeshObjectByID(resourceID uint32) (MeshObject, error) {
	var meshObjectInstance ref
	ret := C.lib3mf_model_getmeshobjectbyid(inst.ref, C.uint32_t(resourceID), &meshObjectInstance)
	if ret != 0 {
		return MeshObject{}, makeError(uint32(ret))
	}
	return newMeshObject(meshObjectInstance), nil
}

// GetComponentsObjectByID finds a components object by its id.
func (inst Model) GetComponentsObjectByID(resourceID uint32) (ComponentsObject, error) {
	var componentsObjectInstance ref
	ret := C.lib3mf_model_getcomponentsobjectbyid(inst.ref, C.uint32_t(resourceID), &componentsObjectInstance)
	if ret != 0 {
		return ComponentsObject{}, makeError(uint32(ret))
	}
	return newComponentsObject(componentsObjectInstance), nil
}

// GetColorGroupByID finds a model color group by its id.
func (inst Model) GetColorGroupByID(resourceID uint32) (ColorGroup, error) {
	var colorGroupInstance ref
	ret := C.lib3mf_model_getcolorgroupbyid(inst.ref, C.uint32_t(resourceID), &colorGroupInstance)
	if ret != 0 {
		return ColorGroup{}, makeError(uint32(ret))
	}
	return newColorGroup(colorGroupInstance), nil
}

// GetSliceStackByID finds a model slicestack by its id.
func (inst Model) GetSliceStackByID(resourceID uint32) (SliceStack, error) {
	var sliceStacInstance ref
	ret := C.lib3mf_model_getslicestackbyid(inst.ref, C.uint32_t(resourceID), &sliceStacInstance)
	if ret != 0 {
		return SliceStack{}, makeError(uint32(ret))
	}
	return newSliceStack(sliceStacInstance), nil
}

// GetBuildUUID returns, whether a build has a UUID and, if true, the build's UUID.
func (inst Model) GetBuildUUID() (bool, string, error) {
	var hasUUID C.bool
	var neededforuUID C.uint32_t
	var filledinuUID C.uint32_t
	ret := C.lib3mf_model_getbuilduuid(inst.ref, &hasUUID, 0, &neededforuUID, nil)
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	bufferSizeuUID := neededforuUID
	bufferuUID := make([]byte, bufferSizeuUID)
	ret = C.lib3mf_model_getbuilduuid(inst.ref, &hasUUID, bufferSizeuUID, &filledinuUID, (*C.char)(unsafe.Pointer(&bufferuUID[0])))
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	return bool(hasUUID), string(bufferuUID[:(filledinuUID - 1)]), nil
}

// SetBuildUUID sets the build's UUID.
func (inst Model) SetBuildUUID(uUID string) error {
	ret := C.lib3mf_model_setbuilduuid(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(uUID)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetBuildItems creates a build item iterator instance with all build items.
func (inst Model) GetBuildItems() (BuildItemIterator, error) {
	var buildItemIterator ref
	ret := C.lib3mf_model_getbuilditems(inst.ref, &buildItemIterator)
	if ret != 0 {
		return BuildItemIterator{}, makeError(uint32(ret))
	}
	return newBuildItemIterator(buildItemIterator), nil
}

// GetOutbox returns the outbox of a Model.
func (inst Model) GetOutbox() (Box, error) {
	var outbox C.sLib3MFBox
	ret := C.lib3mf_model_getoutbox(inst.ref, &outbox)
	if ret != 0 {
		return Box{}, makeError(uint32(ret))
	}
	return *(*Box)(unsafe.Pointer(&outbox)), nil
}

// GetResources creates a resource iterator instance with all resources.
func (inst Model) GetResources() (ResourceIterator, error) {
	var resourceIterator ref
	ret := C.lib3mf_model_getresources(inst.ref, &resourceIterator)
	if ret != 0 {
		return ResourceIterator{}, makeError(uint32(ret))
	}
	return newResourceIterator(resourceIterator), nil
}

// GetObjects creates a resource iterator instance with all object resources.
func (inst Model) GetObjects() (ObjectIterator, error) {
	var resourceIterator ref
	ret := C.lib3mf_model_getobjects(inst.ref, &resourceIterator)
	if ret != 0 {
		return ObjectIterator{}, makeError(uint32(ret))
	}
	return newObjectIterator(resourceIterator), nil
}

// GetMeshObjects creates a resource iterator instance with all mesh object resources.
func (inst Model) GetMeshObjects() (MeshObjectIterator, error) {
	var resourceIterator ref
	ret := C.lib3mf_model_getmeshobjects(inst.ref, &resourceIterator)
	if ret != 0 {
		return MeshObjectIterator{}, makeError(uint32(ret))
	}
	return newMeshObjectIterator(resourceIterator), nil
}

// GetComponentsObjects creates a resource iterator instance with all components object resources.
func (inst Model) GetComponentsObjects() (ComponentsObjectIterator, error) {
	var resourceIterator ref
	ret := C.lib3mf_model_getcomponentsobjects(inst.ref, &resourceIterator)
	if ret != 0 {
		return ComponentsObjectIterator{}, makeError(uint32(ret))
	}
	return newComponentsObjectIterator(resourceIterator), nil
}

// GetTexture2Ds creates a Texture2DIterator instance with all texture2d resources.
func (inst Model) GetTexture2Ds() (Texture2DIterator, error) {
	var resourceIterator ref
	ret := C.lib3mf_model_gettexture2ds(inst.ref, &resourceIterator)
	if ret != 0 {
		return Texture2DIterator{}, makeError(uint32(ret))
	}
	return newTexture2DIterator(resourceIterator), nil
}

// GetBaseMaterialGroups creates a BaseMaterialGroupIterator instance with all base material resources.
func (inst Model) GetBaseMaterialGroups() (BaseMaterialGroupIterator, error) {
	var resourceIterator ref
	ret := C.lib3mf_model_getbasematerialgroups(inst.ref, &resourceIterator)
	if ret != 0 {
		return BaseMaterialGroupIterator{}, makeError(uint32(ret))
	}
	return newBaseMaterialGroupIterator(resourceIterator), nil
}

// GetColorGroups creates a ColorGroupIterator instance with all ColorGroup resources.
func (inst Model) GetColorGroups() (ColorGroupIterator, error) {
	var resourceIterator ref
	ret := C.lib3mf_model_getcolorgroups(inst.ref, &resourceIterator)
	if ret != 0 {
		return ColorGroupIterator{}, makeError(uint32(ret))
	}
	return newColorGroupIterator(resourceIterator), nil
}

// GetTexture2DGroups creates a Texture2DGroupIterator instance with all base material resources.
func (inst Model) GetTexture2DGroups() (Texture2DGroupIterator, error) {
	var resourceIterator ref
	ret := C.lib3mf_model_gettexture2dgroups(inst.ref, &resourceIterator)
	if ret != 0 {
		return Texture2DGroupIterator{}, makeError(uint32(ret))
	}
	return newTexture2DGroupIterator(resourceIterator), nil
}

// GetCompositeMaterials creates a CompositeMaterialsIterator instance with all CompositeMaterials resources.
func (inst Model) GetCompositeMaterials() (CompositeMaterialsIterator, error) {
	var resourceIterator ref
	ret := C.lib3mf_model_getcompositematerials(inst.ref, &resourceIterator)
	if ret != 0 {
		return CompositeMaterialsIterator{}, makeError(uint32(ret))
	}
	return newCompositeMaterialsIterator(resourceIterator), nil
}

// GetMultiPropertyGroups creates a MultiPropertyGroupsIterator instance with all MultiPropertyGroup resources.
func (inst Model) GetMultiPropertyGroups() (MultiPropertyGroupIterator, error) {
	var resourceIterator ref
	ret := C.lib3mf_model_getmultipropertygroups(inst.ref, &resourceIterator)
	if ret != 0 {
		return MultiPropertyGroupIterator{}, makeError(uint32(ret))
	}
	return newMultiPropertyGroupIterator(resourceIterator), nil
}

// GetSliceStacks creates a resource iterator instance with all slice stack resources.
func (inst Model) GetSliceStacks() (SliceStackIterator, error) {
	var resourceIterator ref
	ret := C.lib3mf_model_getslicestacks(inst.ref, &resourceIterator)
	if ret != 0 {
		return SliceStackIterator{}, makeError(uint32(ret))
	}
	return newSliceStackIterator(resourceIterator), nil
}

// MergeToModel merges all components and objects which are referenced by a build item into a mesh. The memory is duplicated and a new model is created.
func (inst Model) MergeToModel() (Model, error) {
	var mergedModelInstance ref
	ret := C.lib3mf_model_mergetomodel(inst.ref, &mergedModelInstance)
	if ret != 0 {
		return Model{}, makeError(uint32(ret))
	}
	return newModel(mergedModelInstance), nil
}

// AddMeshObject adds an empty mesh object to the model.
func (inst Model) AddMeshObject() (MeshObject, error) {
	var meshObjectInstance ref
	ret := C.lib3mf_model_addmeshobject(inst.ref, &meshObjectInstance)
	if ret != 0 {
		return MeshObject{}, makeError(uint32(ret))
	}
	return newMeshObject(meshObjectInstance), nil
}

// AddComponentsObject adds an empty component object to the model.
func (inst Model) AddComponentsObject() (ComponentsObject, error) {
	var componentsObjectInstance ref
	ret := C.lib3mf_model_addcomponentsobject(inst.ref, &componentsObjectInstance)
	if ret != 0 {
		return ComponentsObject{}, makeError(uint32(ret))
	}
	return newComponentsObject(componentsObjectInstance), nil
}

// AddSliceStack creates a new model slicestack by its id.
func (inst Model) AddSliceStack(zBottom float64) (SliceStack, error) {
	var sliceStackInstance ref
	ret := C.lib3mf_model_addslicestack(inst.ref, C.double(zBottom), &sliceStackInstance)
	if ret != 0 {
		return SliceStack{}, makeError(uint32(ret))
	}
	return newSliceStack(sliceStackInstance), nil
}

// AddTexture2DFromAttachment adds a texture2d resource to the model. Its path is given by that of an existing attachment.
func (inst Model) AddTexture2DFromAttachment(textureAttachment Attachment) (Texture2D, error) {
	var texture2DInstance ref
	ret := C.lib3mf_model_addtexture2dfromattachment(inst.ref, textureAttachment.ref, &texture2DInstance)
	if ret != 0 {
		return Texture2D{}, makeError(uint32(ret))
	}
	return newTexture2D(texture2DInstance), nil
}

// AddBaseMaterialGroup adds an empty BaseMaterialGroup resource to the model.
func (inst Model) AddBaseMaterialGroup() (BaseMaterialGroup, error) {
	var baseMaterialGroupInstance ref
	ret := C.lib3mf_model_addbasematerialgroup(inst.ref, &baseMaterialGroupInstance)
	if ret != 0 {
		return BaseMaterialGroup{}, makeError(uint32(ret))
	}
	return newBaseMaterialGroup(baseMaterialGroupInstance), nil
}

// AddColorGroup adds an empty ColorGroup resource to the model.
func (inst Model) AddColorGroup() (ColorGroup, error) {
	var colorGroupInstance ref
	ret := C.lib3mf_model_addcolorgroup(inst.ref, &colorGroupInstance)
	if ret != 0 {
		return ColorGroup{}, makeError(uint32(ret))
	}
	return newColorGroup(colorGroupInstance), nil
}

// AddTexture2DGroup adds an empty Texture2DGroup resource to the model.
func (inst Model) AddTexture2DGroup(texture2DInstance Texture2D) (Texture2DGroup, error) {
	var texture2DGroupInstance ref
	ret := C.lib3mf_model_addtexture2dgroup(inst.ref, texture2DInstance.ref, &texture2DGroupInstance)
	if ret != 0 {
		return Texture2DGroup{}, makeError(uint32(ret))
	}
	return newTexture2DGroup(texture2DGroupInstance), nil
}

// AddCompositeMaterials adds an empty CompositeMaterials resource to the model.
func (inst Model) AddCompositeMaterials(baseMaterialGroupInstance BaseMaterialGroup) (CompositeMaterials, error) {
	var compositeMaterialsInstance ref
	ret := C.lib3mf_model_addcompositematerials(inst.ref, baseMaterialGroupInstance.ref, &compositeMaterialsInstance)
	if ret != 0 {
		return CompositeMaterials{}, makeError(uint32(ret))
	}
	return newCompositeMaterials(compositeMaterialsInstance), nil
}

// AddMultiPropertyGroup adds an empty MultiPropertyGroup resource to the model.
func (inst Model) AddMultiPropertyGroup() (MultiPropertyGroup, error) {
	var multiPropertyGroupInstance ref
	ret := C.lib3mf_model_addmultipropertygroup(inst.ref, &multiPropertyGroupInstance)
	if ret != 0 {
		return MultiPropertyGroup{}, makeError(uint32(ret))
	}
	return newMultiPropertyGroup(multiPropertyGroupInstance), nil
}

// AddBuildItem adds a build item to the model.
func (inst Model) AddBuildItem(object Object, transform Transform) (BuildItem, error) {
	var buildItemInstance ref
	ret := C.lib3mf_model_addbuilditem(inst.ref, object.ref, (*C.sLib3MFTransform)(unsafe.Pointer(&transform)), &buildItemInstance)
	if ret != 0 {
		return BuildItem{}, makeError(uint32(ret))
	}
	return newBuildItem(buildItemInstance), nil
}

// RemoveBuildItem removes a build item from the model.
func (inst Model) RemoveBuildItem(buildItemInstance BuildItem) error {
	ret := C.lib3mf_model_removebuilditem(inst.ref, buildItemInstance.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetMetaDataGroup returns the metadata of the model as MetaDataGroup.
func (inst Model) GetMetaDataGroup() (MetaDataGroup, error) {
	var theMetaDataGroup ref
	ret := C.lib3mf_model_getmetadatagroup(inst.ref, &theMetaDataGroup)
	if ret != 0 {
		return MetaDataGroup{}, makeError(uint32(ret))
	}
	return newMetaDataGroup(theMetaDataGroup), nil
}

// AddAttachment adds an attachment stream to the model. The OPC part will be related to the model stream with a certain relationship type..
func (inst Model) AddAttachment(uRI string, relationShipType string) (Attachment, error) {
	var attachmentInstance ref
	ret := C.lib3mf_model_addattachment(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(uRI)[0])), (*C.char)(unsafe.Pointer(&[]byte(relationShipType)[0])), &attachmentInstance)
	if ret != 0 {
		return Attachment{}, makeError(uint32(ret))
	}
	return newAttachment(attachmentInstance), nil
}

// RemoveAttachment removes attachment from the model.
func (inst Model) RemoveAttachment(attachmentInstance Attachment) error {
	ret := C.lib3mf_model_removeattachment(inst.ref, attachmentInstance.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetAttachment retrieves an attachment stream object from the model..
func (inst Model) GetAttachment(index uint32) (Attachment, error) {
	var attachmentInstance ref
	ret := C.lib3mf_model_getattachment(inst.ref, C.uint32_t(index), &attachmentInstance)
	if ret != 0 {
		return Attachment{}, makeError(uint32(ret))
	}
	return newAttachment(attachmentInstance), nil
}

// FindAttachment retrieves an attachment stream object from the model.
func (inst Model) FindAttachment(uRI string) (Attachment, error) {
	var attachmentInstance ref
	ret := C.lib3mf_model_findattachment(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(uRI)[0])), &attachmentInstance)
	if ret != 0 {
		return Attachment{}, makeError(uint32(ret))
	}
	return newAttachment(attachmentInstance), nil
}

// GetAttachmentCount retrieves the number of attachments of the model.
func (inst Model) GetAttachmentCount() (uint32, error) {
	var attachmentCount C.uint32_t
	ret := C.lib3mf_model_getattachmentcount(inst.ref, &attachmentCount)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(attachmentCount), nil
}

// HasPackageThumbnailAttachment retrieve whether the OPC package contains a package thumbnail.
func (inst Model) HasPackageThumbnailAttachment() (bool, error) {
	var hasThumbnail C.bool
	ret := C.lib3mf_model_haspackagethumbnailattachment(inst.ref, &hasThumbnail)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(hasThumbnail), nil
}

// CreatePackageThumbnailAttachment create a new or the existing package thumbnail for the OPC package.
func (inst Model) CreatePackageThumbnailAttachment() (Attachment, error) {
	var attachment ref
	ret := C.lib3mf_model_createpackagethumbnailattachment(inst.ref, &attachment)
	if ret != 0 {
		return Attachment{}, makeError(uint32(ret))
	}
	return newAttachment(attachment), nil
}

// GetPackageThumbnailAttachment get the attachment to the OPC package containing the package thumbnail.
func (inst Model) GetPackageThumbnailAttachment() (*Attachment, error) {
	var attachment ref
	ret := C.lib3mf_model_getpackagethumbnailattachment(inst.ref, &attachment)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	var _attachmentPtr *Attachment
	if attachment == nil {
		_attachmentPtrVal := newAttachment(attachment)
		_attachmentPtr = &_attachmentPtrVal
	}
	return _attachmentPtr, nil
}

// RemovePackageThumbnailAttachment remove the attachment to the OPC package containing the package thumbnail.
func (inst Model) RemovePackageThumbnailAttachment() error {
	ret := C.lib3mf_model_removepackagethumbnailattachment(inst.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// AddCustomContentType adds a new Content Type to the model.
func (inst Model) AddCustomContentType(extension string, contentType string) error {
	ret := C.lib3mf_model_addcustomcontenttype(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(extension)[0])), (*C.char)(unsafe.Pointer(&[]byte(contentType)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// RemoveCustomContentType removes a custom Content Type from the model (UTF8 version).
func (inst Model) RemoveCustomContentType(extension string) error {
	ret := C.lib3mf_model_removecustomcontenttype(inst.ref, (*C.char)(unsafe.Pointer(&[]byte(extension)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetLibraryVersion retrieves the binary version of this library.
func GetLibraryVersion() (uint32, uint32, uint32, error) {
	var major C.uint32_t
	var minor C.uint32_t
	var micro C.uint32_t
	ret := C.lib3mf_getlibraryversion(&major, &minor, &micro)
	if ret != 0 {
		return 0, 0, 0, makeError(uint32(ret))
	}
	return uint32(major), uint32(minor), uint32(micro), nil
}

// GetPrereleaseInformation retrieves prerelease information of this library.
func GetPrereleaseInformation() (bool, string, error) {
	var hasPrereleaseInfo C.bool
	var neededforprereleaseInfo C.uint32_t
	var filledinprereleaseInfo C.uint32_t
	ret := C.lib3mf_getprereleaseinformation(&hasPrereleaseInfo, 0, &neededforprereleaseInfo, nil)
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	bufferSizeprereleaseInfo := neededforprereleaseInfo
	bufferprereleaseInfo := make([]byte, bufferSizeprereleaseInfo)
	ret = C.lib3mf_getprereleaseinformation(&hasPrereleaseInfo, bufferSizeprereleaseInfo, &filledinprereleaseInfo, (*C.char)(unsafe.Pointer(&bufferprereleaseInfo[0])))
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	return bool(hasPrereleaseInfo), string(bufferprereleaseInfo[:(filledinprereleaseInfo - 1)]), nil
}

// GetBuildInformation retrieves build information of this library.
func GetBuildInformation() (bool, string, error) {
	var hasBuildInfo C.bool
	var neededforbuildInformation C.uint32_t
	var filledinbuildInformation C.uint32_t
	ret := C.lib3mf_getbuildinformation(&hasBuildInfo, 0, &neededforbuildInformation, nil)
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	bufferSizebuildInformation := neededforbuildInformation
	bufferbuildInformation := make([]byte, bufferSizebuildInformation)
	ret = C.lib3mf_getbuildinformation(&hasBuildInfo, bufferSizebuildInformation, &filledinbuildInformation, (*C.char)(unsafe.Pointer(&bufferbuildInformation[0])))
	if ret != 0 {
		return false, "", makeError(uint32(ret))
	}
	return bool(hasBuildInfo), string(bufferbuildInformation[:(filledinbuildInformation - 1)]), nil
}

// GetSpecificationVersion retrieves whether a specification is supported, and if so, which version.
func GetSpecificationVersion(specificationURL string) (bool, uint32, uint32, uint32, error) {
	var isSupported C.bool
	var major C.uint32_t
	var minor C.uint32_t
	var micro C.uint32_t
	ret := C.lib3mf_getspecificationversion((*C.char)(unsafe.Pointer(&[]byte(specificationURL)[0])), &isSupported, &major, &minor, &micro)
	if ret != 0 {
		return false, 0, 0, 0, makeError(uint32(ret))
	}
	return bool(isSupported), uint32(major), uint32(minor), uint32(micro), nil
}

// CreateModel creates an empty model instance.
func CreateModel() (Model, error) {
	var model ref
	ret := C.lib3mf_createmodel(&model)
	if ret != 0 {
		return Model{}, makeError(uint32(ret))
	}
	return newModel(model), nil
}

// Release releases shared ownership of an object instance.
func Release(instance Base) error {
	ret := C.lib3mf_release(instance.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// Acquire acquires shared ownership of an object instance.
func Acquire(instance Base) error {
	ret := C.lib3mf_acquire(instance.ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// SetJournal sets the journal file path.
func SetJournal(journalPath string) error {
	ret := C.lib3mf_setjournal((*C.char)(unsafe.Pointer(&[]byte(journalPath)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetLastError retrieves the last error string of an instance.
func GetLastError(instance Base) (string, bool, error) {
	var neededforlastErrorString C.uint32_t
	var filledinlastErrorString C.uint32_t
	var hasLastError C.bool
	ret := C.lib3mf_getlasterror(instance.ref, 0, &neededforlastErrorString, nil, &hasLastError)
	if ret != 0 {
		return "", false, makeError(uint32(ret))
	}
	bufferSizelastErrorString := neededforlastErrorString
	bufferlastErrorString := make([]byte, bufferSizelastErrorString)
	ret = C.lib3mf_getlasterror(instance.ref, bufferSizelastErrorString, &filledinlastErrorString, (*C.char)(unsafe.Pointer(&bufferlastErrorString[0])), &hasLastError)
	if ret != 0 {
		return "", false, makeError(uint32(ret))
	}
	return string(bufferlastErrorString[:(filledinlastErrorString - 1)]), bool(hasLastError), nil
}

// RetrieveProgressMessage return an English text for a progress identifier.|Note: this is the only function you can call from your callback function.
func RetrieveProgressMessage(theProgressIdentifier ProgressIdentifier) (string, error) {
	var neededforprogressMessage C.uint32_t
	var filledinprogressMessage C.uint32_t
	ret := C.lib3mf_retrieveprogressmessage(C.eLib3MFProgressIdentifier(theProgressIdentifier), 0, &neededforprogressMessage, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizeprogressMessage := neededforprogressMessage
	bufferprogressMessage := make([]byte, bufferSizeprogressMessage)
	ret = C.lib3mf_retrieveprogressmessage(C.eLib3MFProgressIdentifier(theProgressIdentifier), bufferSizeprogressMessage, &filledinprogressMessage, (*C.char)(unsafe.Pointer(&bufferprogressMessage[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferprogressMessage[:(filledinprogressMessage - 1)]), nil
}

// RGBAToColor creates a Color from uint8 RGBA values.
func RGBAToColor(red uint8, green uint8, blue uint8, alpha uint8) (Color, error) {
	var theColor C.sLib3MFColor
	ret := C.lib3mf_rgbatocolor(C.uint8_t(red), C.uint8_t(green), C.uint8_t(blue), C.uint8_t(alpha), &theColor)
	if ret != 0 {
		return Color{}, makeError(uint32(ret))
	}
	return *(*Color)(unsafe.Pointer(&theColor)), nil
}

// FloatRGBAToColor creates a Color from uint8 RGBA values.
func FloatRGBAToColor(red float32, green float32, blue float32, alpha float32) (Color, error) {
	var theColor C.sLib3MFColor
	ret := C.lib3mf_floatrgbatocolor(C.float(red), C.float(green), C.float(blue), C.float(alpha), &theColor)
	if ret != 0 {
		return Color{}, makeError(uint32(ret))
	}
	return *(*Color)(unsafe.Pointer(&theColor)), nil
}

// ColorToRGBA calculates uint8-RGBA-values from a Color.
func ColorToRGBA(theColor Color) (uint8, uint8, uint8, uint8, error) {
	var red C.uint8_t
	var green C.uint8_t
	var blue C.uint8_t
	var alpha C.uint8_t
	ret := C.lib3mf_colortorgba((*C.sLib3MFColor)(unsafe.Pointer(&theColor)), &red, &green, &blue, &alpha)
	if ret != 0 {
		return 0, 0, 0, 0, makeError(uint32(ret))
	}
	return uint8(red), uint8(green), uint8(blue), uint8(alpha), nil
}

// ColorToFloatRGBA calculates float-RGBA-values from a Color.
func ColorToFloatRGBA(theColor Color) (float32, float32, float32, float32, error) {
	var red C.float
	var green C.float
	var blue C.float
	var alpha C.float
	ret := C.lib3mf_colortofloatrgba((*C.sLib3MFColor)(unsafe.Pointer(&theColor)), &red, &green, &blue, &alpha)
	if ret != 0 {
		return 0, 0, 0, 0, makeError(uint32(ret))
	}
	return float32(red), float32(green), float32(blue), float32(alpha), nil
}

// GetIdentityTransform creates an identity transform.
func GetIdentityTransform() (Transform, error) {
	var transform C.sLib3MFTransform
	ret := C.lib3mf_getidentitytransform(&transform)
	if ret != 0 {
		return Transform{}, makeError(uint32(ret))
	}
	return *(*Transform)(unsafe.Pointer(&transform)), nil
}

// GetUniformScaleTransform creates a uniform scale transform.
func GetUniformScaleTransform(factor float32) (Transform, error) {
	var transform C.sLib3MFTransform
	ret := C.lib3mf_getuniformscaletransform(C.float(factor), &transform)
	if ret != 0 {
		return Transform{}, makeError(uint32(ret))
	}
	return *(*Transform)(unsafe.Pointer(&transform)), nil
}

// GetScaleTransform creates a scale transform.
func GetScaleTransform(factorX float32, factorY float32, factorZ float32) (Transform, error) {
	var transform C.sLib3MFTransform
	ret := C.lib3mf_getscaletransform(C.float(factorX), C.float(factorY), C.float(factorZ), &transform)
	if ret != 0 {
		return Transform{}, makeError(uint32(ret))
	}
	return *(*Transform)(unsafe.Pointer(&transform)), nil
}

// GetTranslationTransform creates an translation transform.
func GetTranslationTransform(vectorX float32, vectorY float32, vectorZ float32) (Transform, error) {
	var transform C.sLib3MFTransform
	ret := C.lib3mf_gettranslationtransform(C.float(vectorX), C.float(vectorY), C.float(vectorZ), &transform)
	if ret != 0 {
		return Transform{}, makeError(uint32(ret))
	}
	return *(*Transform)(unsafe.Pointer(&transform)), nil
}

func releaseC(r *ref) error {
	if r == nil || *r == nil {
		return nil
	}
	return Release(Base{ref: *r})
}

func CheckBinaryVersion() error {
	var nBindingMajor uint32 = 2
	var nBindingMinor uint32 = 0
	nMajor, nMinor, _, err := GetLibraryVersion()
	if err != nil {
		return err
	}
	if (nMajor != nBindingMajor) || (nMinor < nBindingMinor) {
		return makeError(0)
	}
	return nil
}
